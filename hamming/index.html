<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Hamming Code for Error Correction | Yiwei Mao</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Hamming Code for Error Correction" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A walkthrough on Hamming codes." />
<meta property="og:description" content="A walkthrough on Hamming codes." />
<link rel="canonical" href="https://yiweimao.github.io/blog/hamming/" />
<meta property="og:url" content="https://yiweimao.github.io/blog/hamming/" />
<meta property="og:site_name" content="Yiwei Mao" />
<meta property="og:image" content="https://yiweimao.github.io/blog/images/2020-02-15-error_correction_files/cube.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-02-15T00:00:00-06:00" />
<script type="application/ld+json">
{"datePublished":"2020-02-15T00:00:00-06:00","headline":"Hamming Code for Error Correction","image":"https://yiweimao.github.io/blog/images/2020-02-15-error_correction_files/cube.png","description":"A walkthrough on Hamming codes.","mainEntityOfPage":{"@type":"WebPage","@id":"https://yiweimao.github.io/blog/hamming/"},"@type":"BlogPosting","url":"https://yiweimao.github.io/blog/hamming/","dateModified":"2020-02-15T00:00:00-06:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://yiweimao.github.io/blog/feed.xml" title="Yiwei Mao" /><!-- the google_analytics_id gets auto inserted from the config file -->



<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-61578211-2','auto');ga('require','displayfeatures');ga('send','pageview');</script>

<link rel="shortcut icon" type="image/x-icon" href="/blog/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Hamming Code for Error Correction | Yiwei Mao</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Hamming Code for Error Correction" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A walkthrough on Hamming codes." />
<meta property="og:description" content="A walkthrough on Hamming codes." />
<link rel="canonical" href="https://yiweimao.github.io/blog/hamming/" />
<meta property="og:url" content="https://yiweimao.github.io/blog/hamming/" />
<meta property="og:site_name" content="Yiwei Mao" />
<meta property="og:image" content="https://yiweimao.github.io/blog/images/2020-02-15-error_correction_files/cube.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-02-15T00:00:00-06:00" />
<script type="application/ld+json">
{"datePublished":"2020-02-15T00:00:00-06:00","headline":"Hamming Code for Error Correction","image":"https://yiweimao.github.io/blog/images/2020-02-15-error_correction_files/cube.png","description":"A walkthrough on Hamming codes.","mainEntityOfPage":{"@type":"WebPage","@id":"https://yiweimao.github.io/blog/hamming/"},"@type":"BlogPosting","url":"https://yiweimao.github.io/blog/hamming/","dateModified":"2020-02-15T00:00:00-06:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://yiweimao.github.io/blog/feed.xml" title="Yiwei Mao" /><!-- the google_analytics_id gets auto inserted from the config file -->



<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-61578211-2','auto');ga('require','displayfeatures');ga('send','pageview');</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Yiwei Mao</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About Me</a><a class="page-link" href="/blog/search/">Search</a><a class="page-link" href="/blog/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Hamming Code for Error Correction</h1><p class="page-description">A walkthrough on Hamming codes.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-02-15T00:00:00-06:00" itemprop="datePublished">
        Feb 15, 2020
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      12 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#error correction">error correction</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#Hamming code">Hamming code</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#Hamming distance">Hamming distance</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#introduction">Introduction</a></li>
<li class="toc-entry toc-h1"><a href="#redundancy">Redundancy</a></li>
<li class="toc-entry toc-h1"><a href="#parity">Parity</a></li>
<li class="toc-entry toc-h1"><a href="#hamming-code">Hamming Code</a>
<ul>
<li class="toc-entry toc-h2"><a href="#error-detection-and-correction-example">Error Detection and Correction Example</a></li>
<li class="toc-entry toc-h2"><a href="#single-error-correction-plus-double-error-detection">Single Error Correction plus Double Error Detection</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#hamming-distance">Hamming Distance</a></li>
<li class="toc-entry toc-h1"><a href="#developments-in-error-correction-codes">Developments in Error Correction Codes</a></li>
<li class="toc-entry toc-h1"><a href="#conclusion">Conclusion</a></li>
<li class="toc-entry toc-h1"><a href="#references">References</a></li>
</ul><h1 id="introduction">
<a class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h1>

<p>Digital communication relies on encoded bits that are transmitted across noisy channels which inevitably suffer from errors. This can be a huge problem for systems that cannot deal with errors. An example of this is interplanetary satellites with limited bandwidth and long communication time delays - by the time the effects of an error is detected, it may be too late to send correction commands. Such systems need to be able to detect errors and correct them if possible. A real application of error correcting codes was on the Mariner 9 mission which required pictures to be sent back from Mars<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup> (this used an error correcting Hadamard code).</p>

<p>This blog will investigate the encoder and decoder stage - how digital information is encoded with error correcting information using the power of numbers. The idea of redundancy and parity is introduced before the Hamming code is described. An example using <code class="highlighter-rouge">Hamming(7,4)</code> is given followed by the notion of the Hamming distance. The blog post will conclude with a brief outline of developments since Hamming’s original paper in 1950.</p>

<h1 id="redundancy">
<a class="anchor" href="#redundancy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Redundancy</h1>

<p>Let the bit length of a message be denoted by $m$. This message can represent $2^m$ unique symbols or characters. If a single bit within the $m$ length bit string is flipped, a different symbol is reconstructed and there is no way of knowing if an error occurred. In order to encode error detection and correction, additional redundant bits are needed. Let the bit length of the redundant bits be denoted by $k$ so the total length of the bits that need to be transmitted is $n=m+k$.</p>

<p>The redundancy factor $R$ is defined to be
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>:</mo><mo>=</mo><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">R := \frac{n}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>
and this measures the efficiency of the encoding.
Redundancy is also a method of generating sparse decompositions of signals and this is known as compressed sensing. This method has applications in computed tomography because image reconstruction can be formulated as a compressed sensing problem<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup>.</p>

<p>A core part of encoding information into the redundant bits is the idea of parity.</p>

<h1 id="parity">
<a class="anchor" href="#parity" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parity</h1>

<p>In the context of binary numbers, parity refers to the number of 1’s that appear in the binary representation. Parity can be encoded by a single bit, for instance the $n^{th}$ bit $b_n$, so that the whole bit string $b_n b_{n-1} \dots b_2 b_1$ contains an even number of 1’s. The parity bit is set to 1 if there are an odd number of 1s in the preceding $n-1$ bits, and set to 0 otherwise:</p>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>n</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>b</mi><mi>i</mi></msub><mspace width="1em"></mspace><mtext> where addition is done modulo 2.</mtext></mrow><annotation encoding="application/x-tex">b_n = \sum_{i=1}^{n-1} b_i \quad \text{   where addition is done modulo 2.}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord"> where addition is done modulo 2.</span></span></span></span></span></span>

<p>This allows for a single bit error to be detected because if there is a single bit flip, there is no longer an even number of 1’s in the bit string. However, double bit errors cannot be detected. The next step is to add error correcting capability and this is given by the Hamming code (Hamming 1950). The following section will introduce the Hamming(7,4) code which has $n=7$ and $m=4$ (this will have $k=n-m=3$ redundant bits).</p>

<h1 id="hamming-code">
<a class="anchor" href="#hamming-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hamming Code</h1>

<p>A Hamming code is constructed by assigning the $k$ redundant bits as <em>check bits</em> over select $m$ information bits. If the check bit received in an $n$ bit string matches the computed parity, then a 0 is recorded, and if it disagrees, a 1 is recorded. The sequence of check bits given by $\mathrm{c_k…c_1}$ provides the position of a single error and is called the <em>checking number</em>. If the checking number is zero, then no error was detected. The checking number is required to represent $m+k+1$ combinations giving a condition
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>≥</mo><mi>m</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><msup><mn>2</mn><mi>m</mi></msup><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">2^k \geq m+ k + 1 \implies 2^m \leq 2^n/(n+1).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.985078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66844em;vertical-align:-0.024em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.800362em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">.</span></span></span></span>
One can check this condition by substituting $n = m+k$.</p>

<p>For the check number to represent the binary number of the error position, the check bits are placed in positions $1,2,4,8,…,2^{k-1}$.
The $i^{th}$ check bit records the parity of bit positions which have a 1 in the $i^{th}$ position in the <em>binary representation</em> So the first check bit will have the parity for bit positions: 1,3,5,7,… which have a 1 in the 1st position. The second check bit will have the parity for bit positions: 2,3,6,7,… which have a 1 in the 2nd position. This is summarised in this Table:</p>

<table>
  <thead>
    <tr>
      <th>Check bit</th>
      <th>Binary</th>
      <th>Check bit 2</th>
      <th>Binary</th>
      <th>Check bit 3</th>
      <th>Binary</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>2</td>
      <td>10</td>
      <td>4</td>
      <td>100</td>
    </tr>
    <tr>
      <td>3</td>
      <td>11</td>
      <td>3</td>
      <td>11</td>
      <td>5</td>
      <td>101</td>
    </tr>
    <tr>
      <td>5</td>
      <td>101</td>
      <td>6</td>
      <td>110</td>
      <td>6</td>
      <td>110</td>
    </tr>
    <tr>
      <td>7</td>
      <td>111</td>
      <td>7</td>
      <td>111</td>
      <td>7</td>
      <td>111</td>
    </tr>
    <tr>
      <td>9</td>
      <td>1001</td>
      <td>10</td>
      <td>1010</td>
      <td>12</td>
      <td>1100</td>
    </tr>
    <tr>
      <td>11</td>
      <td>1011</td>
      <td>11</td>
      <td>1011</td>
      <td>13</td>
      <td>1101</td>
    </tr>
    <tr>
      <td>13</td>
      <td>1101</td>
      <td>14</td>
      <td>1110</td>
      <td>14</td>
      <td>1110</td>
    </tr>
    <tr>
      <td>15</td>
      <td>1111</td>
      <td>15</td>
      <td>1111</td>
      <td>15</td>
      <td>1111</td>
    </tr>
  </tbody>
</table>

<h2 id="error-detection-and-correction-example">
<a class="anchor" href="#error-detection-and-correction-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error Detection and Correction Example</h2>

<p>Consider a 7 bit string $\mathrm{b_7b_6b_5b_4b_3b_2b_1}=\texttt{0111100}$ which encodes a bit string ${\mathrm{m_4 m_3 m_2 m_1} = \texttt{b1011} = 11}$ and check bits $\mathrm{k_3 k_2 k_1} = \texttt{b001}$. This is the Hamming(7,4) code meaning $n=7$ and $m=4$.</p>

<p>The original bit string:
<img src="/blog/images/2020-02-15-error_correction_files/origbits.png" alt="" title="Figure 1: Original bit string." width="50%"></p>

<p>Suppose the bit $\mathrm{m_2}$ in position 5 has an error so instead of the original 1, it is now 0. The checking number $\mathrm{c_3 c_2 c_1}$ can be computed. In Figure 1, the first parity counts an <em>odd</em> number of 1’s in positions 1,3,5, and 7 so $c_1=1$.</p>

<p><img src="/blog/images/2020-02-15-error_correction_files/c1bit.png" alt="" title="Figure 2: Bit string with bit 5 corrupted. First parity bit is checked." width="60%"></p>

<p>Next, the second parity counts an <em>even</em> number of 1’s in the positions 2,3,6, and 7 so $c_2=0$.</p>

<p><img src="/blog/images/2020-02-15-error_correction_files/c2bit.png" alt="" title="Figure 3: Second parity bit is checked." width="60%"></p>

<p>The third parity counts an <em>odd</em> number of 1’s in the positions 4,5,6, and 7 so $c_3=1$.</p>

<p><img src="/blog/images/2020-02-15-error_correction_files/c3bit.png" alt="" title="Figure 4: Third parity bit is checked." width="60%"></p>

<p>This gives a checking number $c_3 c_2 c_1= \texttt{101}$ which is position 5. Therefore, there is an error in position 5 which can be corrected by converting the <code class="highlighter-rouge">0</code> into a <code class="highlighter-rouge">1</code>.</p>

<p>Another example of a Hamming code is triple repetition. Each bit is sent three times and majority rules is applied to decode the message. This is Hamming(3,1) and uses 2 parity bits. Using this code, single errors can be corrected <em>or</em> double errors can be detected but not corrected. This makes sense because if a single bit is flipped, the majority rule recovers the correct bit. However, if two bits are flipped, these errors can be detected but if correction is applied, the wrong bit will be reconstructed. The (7,4) code Hamming introduced in his paper can be extended to (8,4) allowing for single error correction <em>and</em> double error detection.</p>

<h2 id="single-error-correction-plus-double-error-detection">
<a class="anchor" href="#single-error-correction-plus-double-error-detection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Single Error Correction plus Double Error Detection</h2>

<p>Double error detection can be added by using another bit that represents the parity for positions, that when expressed in binary, have a 1 in the $4^{th}$ position. Then there exists three cases with the first being all parity checks pass. The second case is when there is a single error and the last parity check fails. The checking number then gives the position of the error with zero now meaning the error is in the last check position. The last case is then the last parity check is satisfied but the checking number indicates that there is an error. In this case, there is a double error.</p>

<p>Hamming (1950) <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">3</a></sup> gives a way of determining what actions can be done (error detection or error correction) by introducing a metric.</p>

<h1 id="hamming-distance">
<a class="anchor" href="#hamming-distance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hamming Distance</h1>

<p>The distance $D$ between two bit strings ${x}$ and ${y}$ is given by the Hamming distance.</p>

<blockquote>
  <p>The Hamming distance is given by the number of positions (or coordinates) where two bit strings differ.</p>
</blockquote>

<p>This definition satisfies the conditions for a metric:
<span class="katex-error" title="ParseError: KaTeX parse error: No such environment: split at position 7: \begin{̲s̲p̲l̲i̲t̲}̲
        D(x,y)…" style="color:#cc0000">\begin{split}
        D(x,y) = 0 \quad &amp;\text{iff } x=y\\
        D(x,y) = D(y,x) &gt; 0 \quad &amp;\text{if } x\neq y \\
        D(x,y) + D(y,z) \geq D(x,z) \quad &amp;\text{triangle inequality.}
    \end{split}</span></p>

<p>Imagine each code being encoded by corners in a $2^n$ hypercube, then if each code has a distance of $r$ between a neighbouring code, the codes lie on the surface of a $r+1$ sphere centered on some origin. For example, a $r=2$ code with $n=3$ can be: <code class="highlighter-rouge">000</code>, <code class="highlighter-rouge">011</code>, <code class="highlighter-rouge">101</code>, <code class="highlighter-rouge">110</code>. Each code is a distance 2 apart and sit on the corners of a cube as depicted in Figure 5.</p>

<p><img src="/blog/images/2020-02-15-error_correction_files/cube.png" alt="" title="Figure 5: 2 distance code on a cube." width="40%"></p>

<p>When there is a distance of 2 between the codes, then a single error will convert a point on the cube to a coordinate that is meaningless. This corresponds to single error detection. However, this error cannot be corrected since the false code is equidistant to a number of other true codes. A 3 distance code for $n = 3$ can be: <code class="highlighter-rouge">000</code>, and <code class="highlighter-rouge">111</code>. This is shown in Figure 6.</p>

<p><img src="/blog/images/2020-02-15-error_correction_files/cube2.png" alt="" title="Figure 6: 3 distance code on a cube." width="40%"></p>

<p>When there is a single error, the error can be corrected because the false code will be closer to the correct code than the others. A more detailed list of actions is summarised in the following table.</p>

<table>
  <thead>
    <tr>
      <th>Minimum Hamming Distance</th>
      <th>Available Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Unique. No redundancy.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Single error detection</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Single error correction or Double error detection</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Single error correction + Double error detection or</td>
    </tr>
    <tr>
      <td> </td>
      <td>Triple error detection</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Double error correction or</td>
    </tr>
    <tr>
      <td> </td>
      <td>Single error correction + Triple error detection or</td>
    </tr>
    <tr>
      <td> </td>
      <td>Quadruple error detection</td>
    </tr>
  </tbody>
</table>

<p>From the table above, it can be seen that an extra Hamming distance of 2 is needed to correct an additional error and an extra Hamming distance of 1 is needed to detect an additional error.</p>

<h1 id="developments-in-error-correction-codes">
<a class="anchor" href="#developments-in-error-correction-codes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Developments in Error Correction Codes</h1>

<p>More general codes can be made by constructing a parity check matrix which contains error correction abilities based on linear dependent columns<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">4</a></sup>. From there, the mapping between messages and code can be found using a generator matrix computed from the parity matrix<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote">5</a></sup>. The example shown in this blog post relied on operations on a Galois (or finite) field with characteristic 2 (so addition and multiplication is done modulo 2). Other fields can also be used such $\mathbf{F}_{11}$ which is implemented in the User Datagram Protocol (UDP). UDP can also fix erasures - when bits are lost rather than flipped<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote">6</a></sup>. There is also a family of Hamming codes which include extensions and shortenings that allow Hamming codes to perform better or improve the redundancy factor<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote">7</a></sup>.</p>

<p>Multiple error correction codes can be done using Reed-Solomon (RS)<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote">8</a></sup> and Bose-Chaudhuri-Hocquenghem (BCH)<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote">9</a></sup> which can be hard to decode because the number of errors is not known beforehand. By using primitive polynomials for the Galois field, the coding can be done on Linear Feedback Shift Registers (LFSR)<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote">10</a></sup>. The location of errors can be found by solving for the roots of an error locator polynomial<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote">11</a></sup> given by the Massey algorithm<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote">12</a></sup>. Roots of the locator polynomial are found using Chien search and the Forney formula gives a way of computing the values for erasures<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote">13</a></sup>. Following this, Sugiyama invented a method for decoding Goppa codes based on the Euclidean algorithm and Kerlekamp’s key equation, forgoing the need to find the locator polynomial<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote">14</a></sup>. Other decoding methods include the Discrete Fourier Transform (DFT)<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote">15</a></sup>.</p>

<p>Many different types of codes exist including cyclic codes and convolutional or continuous codes. For instance, the Chinese remainder theorem is used to decode Fire codes<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote">16</a></sup> which is a type of cyclic code. Convolutional codes can be decoded with the Viterbi algorithm<sup id="fnref:17" role="doc-noteref"><a href="#fn:17" class="footnote">17</a></sup>. Applications of error correcting coding and decoding extend to public key encryption<sup id="fnref:18" role="doc-noteref"><a href="#fn:18" class="footnote">18</a></sup> amongst others.</p>

<h1 id="conclusion">
<a class="anchor" href="#conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h1>

<p>The main ideas of error correction codes using the Hamming code were explored with the help of an example. Hamming distance was introduced which gives an indication of what actions can be done depending on the minimum Hamming distance. Finally, a brief overview of developments since Hamming’s paper was given.</p>

<h1 id="references">
<a class="anchor" href="#references" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h1>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Brian J Thompson, Robert Rennie Shannon, et al. Space Optics: Proceedings of the Ninth International Congress of the International Commission for Optics (ico IX), volume 9. National Academies, 1974. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Hengyong Yu and Ge Wang. Compressed sensing based interior tomography. Physics in medicine &amp; biology, 54(9):2791, 2009. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Richard W Hamming. Error detecting and error correcting codes. The Bell system technical journal, 29(2):147–160, 1950. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Robert Gallager. Low-density parity-check codes. IRE Transactions on information theory, 8(1):21–28, 1962. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>David JC MacKay and Radford M Neal. Near shannon limit performance of low density parity check codes. Electronics letters, 32(18):1645–1646, 1996. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>Jon Postel. User datagram protocol. Isi, 1980. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>Victor K Wei. Generalized hamming weights for linear codes. IEEE Transactions on information theory, 37(5):1412–1418, 1991. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Stephen B Wicker and Vijay K Bhargava. Reed-Solomon codes and their applications. John Wiley &amp; Sons, 1999. <a href="#fnref:8" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>Robert Chien. Cyclic decoding procedures for bose-chaudhuri-hocquenghem codes. IEEE Transactions on information theory, 10(4):357–363, 1964.9 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>Sybille Hellebrand, Janusz Rajski, Steffen Tarnick, Srikanth Venkataraman, and Bernard Courtois. Built-in test for circuits with scan based on reseeding of multiple-polynomial linear feedback shift registers. IEEE Transactions on Computers, 44(2):223–233, 1995. <a href="#fnref:10" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>T-K Truong, J-H Jeng, and Irving S Reed. Fast algorithm for computing the roots of error locator polynomials up to degree 11 in reed-solomon decoders. IEEE Transactions on Communications, 49(5):779–783, 2001. <a href="#fnref:11" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>G-L Feng and Kenneth K Tzeng. A generalization of the berlekamp-massey algorithm for multisequence shift-register synthesis with applications to decoding cyclic codes. IEEE Transactions on Information Theory, 37(5):1274–1287, 1991. <a href="#fnref:12" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>Douglas A Leonard. A generalized forney formula for algebraic-geometric codes. IEEE Transactions on Information Theory, 42(4):1263–1268, 1996. <a href="#fnref:13" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>Yasuo Sugiyama, Masao Kasahara, Shigeichi Hirasawa, and Toshihiko Namekawa. A method for solving key equation for decoding goppa codes. Information and Control, 27(1):87–99, 1975. <a href="#fnref:14" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>Richard E. Blahut. Transform techniques for error control codes. IBM Journal of Research and development, 23(3):299–315, 1979. <a href="#fnref:15" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>R Chien. Burst-correcting codes with high-speed decoding. IEEE Transactions on Information Theory, 15(1):109–113, 1969. <a href="#fnref:16" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:17" role="doc-endnote">
      <p>G David Forney. The viterbi algorithm. Proceedings of the IEEE, 61(3):268–278, 1973. <a href="#fnref:17" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:18" role="doc-endnote">
      <p>Yuan Xing Li, Robert H Deng, and Xin Mei Wang. On the equivalence of mceliece’s and niederreiter’s public-key cryptosystems. IEEE Transactions on Information Theory, 40(1):271–273, 1994. <a href="#fnref:18" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="YiweiMao/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/hamming/" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>A set of topics I find interesting.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/YiweiMao" title="YiweiMao"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
