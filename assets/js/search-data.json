{
  
    
        "post0": {
            "title": "Make Your Microcontroller Multi-task With Asynchronous Programming",
            "content": "Introduction . You paused your previous task to read this blog post. Once you finish reading, you will move on to your next task. Whether you know it or not, you have learned to embrace asynchonous programming in your daily life. Take cooking for example - say you need to make a noodle soup, a roast, and a fruit salad. These activities involve waiting between tasks and in order to finish the cook efficiently, you need to arrange the timing of tasks. A possible solution is to first put a pot of water to boil, then prepare the vegetables and meat to oven, then spice up the soup and add dry noodles, then cut up the fruit into a bowl (done), then serve the noodle soup (done), then take out the roast from the oven (done). If you did each task sequentially (or synchronously), then you would have wasted lots of time waiting doing nothing! . In the context of microcontrollers, they live in an environment which they need to respond to hardware events such as data available on UART, buttons, etc (I/O bound tasks) which involve waiting for an input. Your program needs to respond to these asynchronous events but may also have time dependent tasks running. Asynchronous means these events do not happen at the same time. . Why Consider Asynchronous Programming? . Consider the following; the controller in an 16x2 LCD display requires small wait times between commands. If we naively wrote a routine that sent a string to the LCD inserting delays when needed, our code will not be able to respond to other events while it is waiting. The presence of blocking delays to manage timing (which prevents other code from being run), is inefficient. So what are our options? We can try writing an event loop that checks the system time and lump many if statements together checking if certain tasks need to be run and run them during the wait time. This quickly becomes unwieldy for a large number of tasks and increases the cognitive load to manage it all. What we want is some way of submit tasks to a scheduler which can then manage which tasks need to be run at which time for you without the hassles of managing it yourself. In effect, we want to be able to multi-task, be efficient at utilising the CPU&#39;s available clock cycles, and produce code that is responsive to events. Enter asynchronous programming. . Note: For those of you wondering why not threading or multiprocessing? Asynchronous programming offers lower overhead and resources making it preferred for low power microcontrollers. If you are interested, the Raspberry Pi Pico has uasyncio which we will see later and _thread that can run tasks on the second core. In this blog post, I will introduce some terminalogy and discuss the advantages of asynchronous programming. At the end, I will show you how you can write asynchronous programs for your Arduino (using C) and Raspberry Pi Pico (using MicroPython). You may want to find an Arduino or Raspberry Pi Pico (with optional extra LEDs and resistors to try blinking multiple LEDs asynchronously), and give the example a go. The example will use the builtin LED. If you are reading this then I think it&#39;s safe to say you have some experience in either C/C++ writing code for Arduino or writing MicroPython code for the Raspberry Pi Pico. . Warning: There is no asyncio-like library for Arduino so my implementation is an attempt at making something similar. The MicroPython content part of this blog posts was inspired by this intro to Python&#39;s asyncio] and Application of uasyncio to hardware interfaces. . Terminology . Parallelism: The ability to perform multiple operations simultaneously. Multiprocessing is an example that spreads tasks over multiple CPU cores. | Concurrency: The ability to execute more than one program or task simultaneously. Tasks can run in an overlapping manner and need not be parallel. | I/O bound task: A task dominated by waiting for input/output to complete. | Coroutine (coro): A specialised function (co-operative routine) that is intended to run concurrently with other coros. Concurrency is achieved by periodically yielding to the scheduler, enabling other coros to run. | Event loop: A loop that monitors tasks to run. For microcontrollers, we have this running on a single CPU core and single thread. | Scheduler: An event loop that facilitates asynchronous programming. | Pre-emptive scheduling: A scheduling technique that temporarily interrupts an running task without cooperation from the task, for it to be resumed at a later time. | Cooperative scheduling: A scheduling technique that never initiates a context switch between tasks. It has lower overhead compared to pre-emptive scheduling and requires tasks to periodically yield to the scheduler. | . Now that we know about the terminology involved, how can we actually write asynchonous code? . A Cooperative Scheduler for Arduino . Every beginner starts out with the Blink sketch and eventually learns that there are limitations in using delay. Suppose we have n LEDs that require blinking at different rates. (Instead of LEDs, we may have sensors we want to read from at different rates and actuators to update.) There&#39;s no easy way to do this using delay and it certainly will not be very customisable. To solve this, the next sketch is BlinkWithoutDelay which uses if statements to check timing against the system time. The cooperative scheduler I introduce here is much like using BlinkWithoutDelay with the if statement part abstracted away. . if (currentMillis - previousMillis &gt;= interval) { // Let&#39;s abstract this part away using a scheduler! // save the last time you blinked the LED previousMillis = currentMillis; ... . At the core, the scheduler consists of a queue of tasks implemented as an array of void function pointers and scheduled run times. Clone my respository (https://github.com/YiweiMao/scheduler) or copy the .cpp and .h file to your project. This implementation is very lightweight and is designed to be easy to use. There is only one function to remember which is the run_later function and the scheduler handles the timing for you. Functions that can be submitted into the queue needs to be of type void and accept no arguments. For example, to schedule a callback function called blinkLED to run 500 ms later, simply write run_later(blinkLED,500); and to place a task that automatically reschedules itself, use run_later within the task. This is how a blinkLED function can be written so the builtin LED will blink in the background. . void blinkLED(){ short toggle_delay = 250; // ms run_later(blinkLED, toggle_delay); // reschedules itself! pinMode(LED_BUILTIN,OUTPUT); digitalWrite(LED_BUILTIN,!digitalRead(LED_BUILTIN)); } . After you call blinkLED, the builtin LED will continue to blink in the background and you will have clock cycles to run other code using run_later. . Fill up the scheduler before you run the even loop; for example, within the void setup() block. . To run the event loop, end your sketch with . void loop() { run(); } . Hint:There are other schedulers for Arduino. See a list of five including FreeRTOS and CoopThreads. The closest implementation to what is present here is probably TaskManagerIO. . Micropython&#39;s Asyncio Approach for Raspberry Pi Pico . There is no doubt that Python is a very popular programming language widely used in many disciplines. If you already know python, you don&#39;t need to learn a foreign syntax to imediately begin writing code for microcontrollers using Micropython. The Raspberry Pi Pico is a cheap accessible microcontroller than can be programmed using Microcontroller and has access to most of Python&#39;s asyncio functionality builtin. I personally use Visual Studio Code with the Pico-Go extension to upload/run code on the Pico and access the REPL. . The example here will use the builtin LED but you can add an additional LED to try multitasking using the event loop. First we important the relevant libraries and define some LEDs before moving onto defining asynchronous functions. . from machine import Pin import uasyncio as asyncio # create LED objects builtin_led = Pin(25,Pin.OUT) LED_TOGGLE_TIME_MS = 50 second_led = Pin(16,Pin.OUT) SECOND_LED_TOGGLE_TIME_MS = 200 . Asynchronous Functions / Coroutines . To make our lives easier, here is a decorator to convert an ordinary Python function into one that will run repeatedly with a specified wait time. This decorator basically places your functions into a loop and wraps the loop with async def. When the await keyword is reached, your code will yield to the scheduler allowing other async functions to run until the await time is over. . Note: Decorators are a way to modify the behaviour of functions. They are functions that take other functions as inputs and return the modified function. . def reschedule_every_ms(t): &quot;&quot;&quot;Decorator for a callback that will keep rescheduling itself.&quot;&quot;&quot; def inner_decorator(cb): async def wrapped(*args, **kwargs): while True: await asyncio.sleep_ms(t) cb(*args, **kwargs) return wrapped return inner_decorator . Now let&#39;s use this decorator to create coroutines or coro for short. . @reschedule_every_ms(LED_TOGGLE_TIME_MS) def blink_deco(): builtin_led.toggle() @reschedule_every_ms(SECOND_LED_TOGGLE_TIME_MS) def second_blink_deco(): second_led.toggle() . blink_deco and second_blink_deco are now coros that we can insert into the event loop. . Exception Handling . In case we want to stop our code running on the Pico with a KeyboardInterrupt and enter the REPL, we need to exit gracefully. This is provided by the following code snippet. . def set_global_exception(): &quot;&quot;&quot;Allow for exception handling in event loop.&quot;&quot;&quot; def handle_exception(loop, context): import sys sys.print_exception(context[&quot;exception&quot;]) sys.exit() loop = asyncio.get_event_loop() loop.set_exception_handler(handle_exception) . Event Loop . Similar to how we added tasks into the scheduler using run_later in Arduino&#39;s void setup() function, we can need to add tasks using asyncio.create_task in an async def main() function like so. . Tip: asyncio.create_task submits a task to the event loop to run concurrently with other tasks. . # Add Coros into the Event Loop async def main(): set_global_exception() # Debug aid # insert coros into queue! asyncio.create_task(blink_deco()) asyncio.create_task(second_blink_deco()) while True: # run forever await asyncio.sleep_ms(1000) # Run the Event Loop try: asyncio.run(main()) except KeyboardInterrupt: print(&quot;Keyboard Interrupted&quot;) except asyncio.TimeoutError: print(&quot;Timed out&quot;) finally: asyncio.new_event_loop() # Clear retained state . We now have two LEDs blinking asynchronously! . Conclusion . We explored what asynchronous programming may look like for Arduino using a task scheduler written in C and also for a Raspberry Pi Pico using the builtin uasyncio library. The asynchronous programming methodology presented here may at first glance look overcomplicated for what is just blinking LEDs but remember that using this framework, we have avoided all blocking delays and our code will still be responsive while waiting for I/O. Automatically rescheduling functions also allows us to &quot;set and forget&quot; and focus on writing one task at a time without worrying about how the timing of other functions are affected for the most part. In other words, it allows us to more easily write programs at scale and make the most of a microcontroller&#39;s limited clock cycles. . Give it a go and let me know of any success (or fail) stories in the comments below! .",
            "url": "https://yiweimao.github.io/blog/async_microcontroller/",
            "relUrl": "/async_microcontroller/",
            "date": " • Jul 21, 2021"
        }
        
    
  
    
  
    
        ,"post2": {
            "title": "Ping Pong LED Clock",
            "content": "Introduction . Ping pong balls are great light diffusers and combining them with individually addressable RGB LEDs makes for a pretty display. This ping pong clock can show the time and background animations (more on that later). Since each &quot;pixel&quot; is placed in a hexagonal lattice, the typical digits font for standard 7-segement displays can&#39;t be used unless the digits are slanted. . In this blog post, I will describe how I built the thing and my reasoning behind some design choices. Then I will outline how I created my animations so you can fork my repository and create your own animations. At the end, there will be some animations for you to watch! . My code can be found at this repo link. . Materials . I ordered all the materials to build this well before the global pandemic but only got to making it recently. The ping pong balls and LED strip took many weeks to arrive from overseas. . At least 128 ping pong balls. I used low cost &quot;glossy&quot; plasticky ping pong balls ~$20. Better to use proper ping pong balls that can diffuse the light more efficiently. | 5 m of WS2128B LED strip at 30 LEDs/m. (This gives you 150 RGB LEDS which is more than the required 128. ~$20) | 2 m of 3pin wire ~$3. You can use single connection multicore wire as an alternative. | Some lead-free solder ~$2. Any solder will do really. | Microcontroller (I used an Arduino Nano Clone ~$3. Not enough RAM for scrolling text animations so consider an ESP32 board?) | A Real Time Clock with coin cell battery. I didn&#39;t have one so I used a software implementation instead. That meant I couldn&#39;t keep track of the right time after a powerdown. But hey, a broken clock is right twice a day! | MDF board to attach all the LEDs onto ~$4. | Wood Frame ~$5. You will need a miter saw to cut the frame at 60 degree angles. | Some screws/nails/epoxy to fit the frame together ~$1. | Lots of hot glue. I used a 30 cm stick ~$1. | A 5 V power supply. I&#39;m using a phone charger which can provide up to 2 A of current. If you plan to turn all the LEDs to max brightness, you&#39;ll need like 8 A but for all intents and purposes, I think 2 A is enough. You can use a FastLED setting to set a limit to the power draw and the brightness will automatically adjust for you. | . The original instructable which describes how to build and program the LED clock is a great resource so definitely take a look! In it, he/she uses competition quality ping pong balls rather than the cheap ones I used which tended to be glossy and inconsistent in the amount of plastic for each ball. I&#39;m inclined to agree that the higher quality ping pong balls are way better despite being more costly. The cheap plasticky ping pong balls don&#39;t diffuse the light enough and the LED position can seen from behind. If you do choose to use the cheap ping pong balls however, I found that you can recreate the really great light diffusion by stacking two cut halves together. Looking from afar, I can&#39;t notice any blemishes (or at least, my mind won&#39;t let me). . The Build . From a bag of 150 ping pong balls, . . each ball goes into a jig I made using LEGO to hold the ball in place while I used an X-acto knife to slice along the seam. If you don&#39;t slice along the seam, you can see the seam when you shine the LED behind it! This is the most tedious part and took me a whole day. . . I then used hot glue to double stack each half to improve the diffusion. Once the improved halves are done, I glued two together while aligning it to a flat surface (edge of a tissue box in my case). The instructable used two long lengths of wood to ensure each row is straight - it&#39;s impossible to mess up the straight line gluing two pieces together. Then extend to the final shape shown in Figure 6 (2 rows of 17, 2 rows of 18, 2 rows of 19 and 1 row of 20). I used hot glue quite liberally to make the structure rigid but it still ended up rather fragile - not a problem once it&#39;s in the frame and glued down. . . I cut the LED strips such that the included JST connector both starts and ends the whole thing and these connectors are pulled through a 12 mm diameter hole. This means you can provide 5 V power from both ends. I follwed the wiring shown in Figure 8. Keep in mind the direction shown on the strip! I found that the wiring wasn&#39;t noticible after the ping pong balls were placed so didn&#39;t bother putting them behind the MDF board like the instructable. Sticky tape was used to temporarilly fix the strip positions while I test for light leakage after placing the ping pong balls on top. . . The reason why I&#39;m not providing exact dimensions for the frame is that the dimensions will depend on how well you glue all the ping pong ball pieces together. Since each ping pong ball was 40 mm diameter, the row of 20 should be 800 mm long but mine ended up being 810 mm. With the frame, the overall dimensions was roughly 850 mm long and 290 mm tall. . . . Tip: Make sure you have some space behind the frame to place the microcontroller and power supply. . Before you fix the LED strips in place with more hot glue, turn on all the LEDs and make sure each LED is underneath a ping pong ball. Look up the FastLED library to see how to do this - it&#39;s very simple and there are great example codes to run! . . LED Index Look Up Table . The crux of my animations rely on knowing which LED number along the connected strip of 128 corresponds to a two dimensional position. From Figure 8, I label each LED by it&#39;s strip index which you can see in Figure 9. . . . Imagining the display as a parallelogram slanted to the left, I turned Figure 9 into a two dimensional array (look up table) with values corresponding to the strip index. For the positions that don&#39;t exist, I put values of 999. . const int led_address[7][20] = { {999,999,999,12,13,26,27,40,41,54,55,68,69,82,83,96,97,110,111,124}, // 0th row {999,999,1,11,14,25,28,39,42,53,56,67,70,81,84,95,98,109,112,123}, // 1st row {999,2,10,15,24,29,38,43,52,57,66,71,80,85,94,99,108,113,122,125}, // 2nd row {0,3,9,16,23,30,37,44,51,58,65,72,79,86,93,100,107,114,121,126}, // 3rd row {4,8,17,22,31,36,45,50,59,64,73,78,87,92,101,106,115,120,127,999}, // 4th row {5,7,18,21,32,35,46,49,60,63,74,77,88,91,102,105,116,119,999,999}, // 5th row {6,19,20,33,34,47,48,61,62,75,76,89,90,103,104,117,118,999,999,999}, // 6th row }; . Now that I have access to the row and coloumn in the ping pong display, I went ahead and added custom animations. . . Important: Using this look up table together with arrays of structs for storing animation state quickly ate up the RAM on my Arduino Nano (which has 2 KB). To add more complex animations and scrolling text, you will need something like a Teensy or ESP32. I haven&#8217;t tried it yet, but this Qt Py seems like a viable cheap Arduino compatible option with 32 KB of RAM. . FastLED Frame Buffer . I used the FastLED library for controlling all 128 RGB LEDs. After connecting 5 V and GND, the remaining data pin can be connected to any digital pin (I used pin 6). This made the hardware really easy to interface and minimsed mistakes with soldering and wiring. (Imagine controlling all the LEDs with its own digital pin!) . The state of all the LEDs are stored in an array that holds the red, green, and blue values for each LED. . CRGB leds[NUM_LEDS]; FastLED.addLeds&lt;WS2812, LED_PIN, GRB&gt;(leds, NUM_LEDS).setCorrection( TypicalLEDStrip ); . Setting Colours . Updating this frame buffer does not update the LEDs until you call FastLED.show(). Before writing to the frame buffer, I first use FastLED.clear() to zero all the LEDs to CRGB::Black. . Tip: Standard HTML colours can be accessed via CRGB::colour_name. Some examples are CRGB::White, CRGB::Yellow, CRGB::Teal, and CRGB::Gray. . You can also use the HSV colour space and set the hue, saturation, and value using CHSV(unit8_t hue,unit8_t sat,unit8_t val) which will automatically convert to an RGB value to be stored. FastLED has two rainbow spectrums - I used the default which spaces out the oranges and yellows more and is visually more &quot;rainbow-like&quot;. . Power consumption . Each RGB LED can draw 60 mA and since there are 128 of them, that&#39;s 7.68 A. In all my applications, I do not need to turn all the LEDs white on max brightness anyway. I found full brightness too bright and that half brightness was good enough. I used a 5 V, 2 A phone charger. FastLED provides as function to limit the power consumption automatically so that LED brightnesses are modified before writing out the frame buffer. This means you can code your animations assuming full power while testing on a smaller power supply, then change a setting for deployment. . FastLED.setMaxPowerInVoltsAndMilliamps(5,500); // Also, see this function // FastLED.setBrightness( BRIGHTNESS ); . For example, if the value is 11.5 after FastLED adjusts the value, FastLED will use temporal dithering to make it appear as 11.5 by quickly switching between 11 and 12. Neat! . Timing . Each RGB LED takes around 30 us to be written. To update the whole clock display, the whole process takes 3.84 ms. Theoretically, that means the max refresh rate is 260 Hz but it takes time to clear the frame buffer, cycle through the look up table, compute colour values and write the new animations. In practice, I found a 20 Hz refresh rate was plenty for smooth animations. . Instead of using the Arduino delay() function for timing, I used FastLED.delay() instead as it allows for temporal dithering as described above. . . Warning: FastLED will turn off interrupts temporarily while updating the LED strip due to the tight timing needed to write to the LEDs. . Foreground Modes . When programming the animations, I decided that it would be sensible to segregate the time (and any text?) to the foreground while keeping the rest to the background. The foreground LED colour values will overwrite the background values. . Here&#39;s what it looks like displaying the time in rainbow colours with a black background. . . Slanted Digits . I also have an option to make the time appear in slanted mode as well as a no time option. The no time option is great for seeing the background animation. In practice, you can mix and match foreground and background modes. . . Background Animations . Rolling Rainbow . The rainbow background works well with either the foreground set to CRGB::White (as shown in Figure 12) or CRGB::Black. . . Twinkle . In this one, I randomly chose LEDs to flash white and fade away. . Storm . In creating this storm animation, I wanted a fast way to generate random numbers. It just so happens that FastLED provides random8 which I used liberally to generate a raindrop&#39;s path downward (and the lightning strikes!). . . Interviewer: Your resume says you are quick at generating random numbers. Give me a sequence of random numbers. | random8: Here you go.... | Interviewer: That doesn&#39;t seem random to me.... | random8: But it was quick! . Note: random8 is advertised as fast and is not truly random but for me, it is random enough. | . Campfire . To make this firey animation, I just used random8 to generate brightness values for the bottom four rows. Each row up is slightly less bright. I also randomly shifted the red hue towards orange. . . Fireworks . The fireworks animation was by far the most difficult but it looks really impressive (at least to me). The hexagonal pattern to the LEDs naturally lent itself to show an explosion of light in 6 directions. Since each LED has two LEDs directly above, I used random8 to choose Whether the firework rises to the left or the right. More random8 was used to change the explosion height to two different rows and the hue. Finally, I then dim the LEDs to similate the fireworks fading away. . . General Animation Method . For each style of animation, I used a struct to define a type that defines the state of the animation. For example, let&#39;s look at the fireworks animation. In the code snippet below, the firework type holds the starting $x$ position in the bottom row, the direction going north-west or north-east in the hexagon lattice, the stage or the current step in the animation sequence, the randomly generated hue, and the height offset that determines which row to explode. I then create an array of these struct with size defined by MAX_FIREWORKS. . #define MAX_FIREWORKS 12 struct firework_t { int pos = -1; // LED number in last row int direction = 0; // 0 is left, 1 is right int stage = 0; // remember where each firework animation is up to char hue = 0; // colour of each firework int height_offset = 0; // sometimes lower by one. }; . The next frame as defined by the user&#39;s REFRESH_RATE steps through the animation stages and sometimes randomly starts a new firework should the number of current fireworks be less then MAX_FIREWORKS with some probability. I then loop through all the array and redraw the LED states into the frame buffer according to each fireworks&#39; current animation stage. All that&#39;s left is to define what each stage or step looks like and I used if/else if statements to do the job. The same method is applied for the twinkle and storm animation. . Together with the LED index look up table defined by a left-ward sloping parallelogram in Figure 9, and this struct based rasteriser method, it is relatively straightforward to generate your own neat animations! . Warning: With the limited RAM in an Arduino Nano (2 KB), I found it really hard to fit more than two types of animations on chip. When the compiler gives you the warning Low memory available, stability problems may occur and the RAM usage is &gt;90%, be wary that your animations may freeze as it did for me. I made it work by lowering MAX_FIREWORKS and MAX_RAINDROPS until the freezing disappeared but it&#8217;ll be better to use a microcontroller with more RAM. . Potential Improvements . Here is a list of improvements I could make to my ping pong LED clock: . Use a hardware RTC rather than use software | Implement scolling text | Use FastLED colour palettes | Attach light sensor and auto-adjust FastLED brightness | Attach PIR motion sensor and turn on display when there is someone to look at it | Attach temperature/humidity/pressure sensor and display stats | Connect to Wifi (e.g. using an ESP32) | These improvements will require more hardware that I don&#39;t have right now... but you can totally put them on your shopping list when you order the materials to make your own ping pong LED clock and show me what you make! . Conclusion . We saw how I put together a ping pong LED clock inspired by an instructable and some animations. Both my hardware and software design choices were explained and my code is freely available at this GitHub repo. . I hope I inspired you to make your own ping pong LED clock with your own cool animations! Let me know how it goes in the comments below! .",
            "url": "https://yiweimao.github.io/blog/ping_pong_led_clock/",
            "relUrl": "/ping_pong_led_clock/",
            "date": " • Jan 14, 2021"
        }
        
    
  
    
  
    
        ,"post4": {
            "title": "Defeating Self-sabotage: An Opinionated Guide to PhD Writing",
            "content": "Introduction . As a PhD student or academic, writing is a core element of the job. In order to succeed, you need to be a productive writer. However, completing a PhD is by no means easy and I can attest to some of the self-sabotaging behaviours that will be mentioned in this post. Half of the reason I wrote this is to summarise a bunch of tips I’ve come across for my future self because I know I will need to be reminded of them. The other half is to put this out for other PhD students and academics in the hope that it is useful. . What Writing Is Not . Let’s start by discussing what writing is not and get some preconceptions out of the way. Gardiner and Kearns puts this aptly: . Writing isn’t editing: you should not spend your … time trying to find the perfect word or getting your grammar right. Writing isn’t reading journal articles for research: write first and read afterwards, so that your writing shows you what you need to read. Writing isn’t referencing: when you make that killer argument and want to reference Smith and Brown (2006; or maybe it was 2007?), don’t stop and look it up. Write “Smith &amp; Brown (200??)” and keep going. You can look up the reference later. Furthermore, writing is not formatting, literature searching, photocopying, e-mailing or nosing around on Facebook. Writing … means putting new words on the page or substantially rewriting existing words. . Self-Sabotaging Behaviours . Kearns1 lists seven self-sabotaging behaviours. This guy runs a lot of programs focusing on developing cognitive and emotional skills for PhD students at Flinders University and has written books and papers on the topic. People are more likely to self-handicap when the task is very important as Greenberg2 found and PhD students are particularly susceptible. I would suggest taking a look at following list and not use any of them for an excuse as you will have some level of control over them. This will be very difficult and will require improving study habits and time management. . Overcommitting Taking on so many things that your high priority goals suffer . | Busyness Looking like you are very busy but, in reality, only less important things are actually getting done . | Perfectionism Setting unrealistic and impossible expectations . | Procrastination Putting off important or necessary tasks, often until the last minute . | Disorganisation Not developing a routine or system that makes managing your time and life easier . | Not Putting in Effort Not practising or trying very hard . | Choosing Performance Debilitating Circumstances Trying to work in a busy or unsuitable location or situation . | Kearns uses the following steps in the Cognitive Behavioural Coaching model explained in 1. . Prepare Yourself To Write . Ergonomics . This tip was inspired by this blog post. . If you are feeling uncomfortable, then you are certainly not going to feel comfortable writing for extended periods of time. You don’t want to damage your neck, back, arms by having poor posture. Ideally, you want your screen at approximately eye height to prevent straining the neck and this pretty much means raising your monitor if you haven’t already. Using textbooks, pads of paper, or boxes is cheap way to do so. For those who use a laptop, you can raise your display and use a separate keyboard and mouse. If you don’t have a dedicated office space and need to move your workstation around, you use a box to raise your laptop screen and use it to store your keyboard and mouse as you move. You can even use your rolled up backpack in replacement of said box. For the keyboard, you want your elbows approximately perpendicular to your torso as you type. . I’ve used the large boxes Amazon ships me to make a standing desk setup. Standing can become uncomfortable after a long time so I find it helpful to transition between standing and sitting every so often. . Being uncomfortable will distract you from writing so consider how this might work for you. You don’t need an expensive motorised table, fancy laptop stands, etc to get started. . Touch Typing . You will spend hours… days… years typing so it’s definitely worth your time learning how to touch type. It also helps with ergonomics since you don’t need to look at your keyboard anymore. A good typist can get over 100 words per minute but in practice, unless you are transcribing, you don’t need to be this fast. I find it good enough to type at thought speed. I trained by going through a dictionary and typing many words but you can train in other ways. For example, those playing fast paced online multiplayer games get really good at typing to communicate with team members and asking for assistance as the situation calls for it. . As a side note, I don’t remember what some of my passwords are because it’s in muscle memory! My fingers know what it is and to work it out (say if I needed the password on my phone), I have to visualise a keyboard and play back where my fingers go. . It’s bizarre that I still see academics hunt and peck as they type. For a job that requires writing papers and answering many emails, I think it’s definitely a good investment to increase your typing speed. . Back Up Your Work Regularly and Use Version Control . I remember a day in the past, I lost a day of work because I forgot to save a Word document. I was devastated for about 10 minutes before smashing the report out again because it was due that day. That was stressful! You don’t want this to happen to you when writing your thesis so back up your work regularly. . I now use Overleaf to write my reports/papers and it saves as you type so you don’t lose a second of work. It’s the Google Docs for LaTeX and also integrates with GitHub for version control. . For software projects, I use GitHub and this is great for text files (since you check a diff for every commit) but also works for saving binary files. The advantage of using a version control system is the ability to roll back changes and try experiments in a separate branch before merging with the master branch. This is great for collaboration where your team may be working on the same code base but separate modules. . . Get Into The Groove . Binge Writing or Snack Writing . Should you set aside a large block of time for writing or many small blocks (snack writing)? I’ll let this article do the talking: . Big blocks hardly ever come, and when they do, usually not get used productively. When possible, try snack writing first thing in the morning. Our experience suggests that this increases the chances of success by minimizing distractions and ensuring that you have sufficient energy to write clever things. However, for snack writing to lead to really high-quality results, you also need to write in a very specific way. . ABCDEs of Writing . Figure 3, which I sourced from 3 summarises what the ABCDEs of writing are: . . The most striking realisation I had from reading this paper (Gardiner and Kearns, 2012) was that the best motivator for writing is writing itself. They challenge other misbeliefs about writing like “it won’t be good enough”, “I’m not ready yet”, and “I don’t have enough time” and offer evidence based tips for writing. This paper gave me the reason to writing this blog post, so I think it’s well worth reading. . Form A Writing Group . Inspired by NaNoWriMo (which is short for National Novel Writing Month), I created a writing group with a few friends also doing their PhD. I you don’t know what NaNoWriMo is, here is the description from Wikipedia . National Novel Writing Month is an annual Internet-based creative writing project that takes place during the month of November. Participants attempt to write a 50,000-word manuscript between November 1 and November 30. . Writing with others creates some accountability and with the mutual encouragement, it should also help you put words down no matter if it’s good or not. To start, I would recommend going for a smaller goal like 100 words/day so by the end of the month, you will have 3000 more words that you never had before. . When starting a writing group, I need to stress it is not a competition (that is a scarcity mindset which is founded on the idea that if someone is successful, it means you lose). You should instead have a abundance mindset - that is there are enough resources and successes for everyone so you can celebrate the success of others. It is worth a segue to take a look at Stephen Covey’s The 7 Habits of Highly Effective People4 and apply some of the interdependence tips to your writing group. . Segue: The 7 Habits of Highly Effective People . In summary, there are three stages of increasing maturity: dependence, independence, and interdependence - and the 7 habits are designed to get you to interdependence and being good leaders and team players that can combine talents. . Dependence $ rightarrow$ Independence . Don’t be reactive. Be proactive. | Begin with the end in mind. Don’t just act, thinking first about the end goal and consequences as you plan towards you goal. | First things first. Do what is important first. | You can categorise tasks into four quadrants shown in Figure 4. . Quadrant I. Urgent and important (Do) - important deadlines: crises, deadline driven projects, meetings, and preparations | Quadrant II. Not urgent but important (Plan) - long term development: prevention, value clarification, relationship building, empowerment | Quadrant III. Urgent but not important (Delegate) - distractions with deadlines: interruptions, some phone calls, some emails and reports, some meetings | Quadrant IV. Not urgent and not important (Eliminate) - frivolous distractions: trivia, junk email, some phone calls, time wasters, “escape” activities | . The ideal quadrant to work in is II. That means starting on papers and assignments early and minimising time spent on distractions. As a PhD student, you are often delegated tutoring roles by lecturers and while you can learn a lot about communicating ideas and gauging understanding while solidifying your own understanding, know that it can be a distraction. So, if money is not an issue, it is up to your own judgement as to what works for you - remember habit 2: begin with the end in mind. . Independence $ rightarrow$ Interdependence . Think Win-Win. Seek mutually beneficial solutions. | Seek first to understand, then to be understood. | Synergise. Combine people’s strength through positive teamwork and achieve goals that would not be attainable if done alone. | Continual Improvement . The final habit is to . Sharpen the Saw; Growth: Learn, commit, do. | Balance and renew your resources, energy and health to create a sustainable, long-term, effective lifestyle. . Solving The Issue Of Being Unsure Of What To Write . Misconceptions . Sometimes people think they should write when they are “ready” and need to read endlessly or conduct more experiments. Ironically, this makes them less likely to write and more confused. And sometimes people think they should understand the material first and then write but in practice, after writing, they find that there were inconsistencies and certain parts didn’t flow well - signs that they didn’t understand the material coherently in the first place. According to this Nature article, . In fact, writing clarifies your thinking. Writing is not recording - you don’t just take a photocopy of what is in your head and put it on the page. It is a far more creative and interactive process. As you write, you develop your thoughts. Writing is, in fact, rigorous thinking. Writing means putting new words on the page or substantially rewriting old words. . Rubber Duck Debugging . If you find yourself stuck on how to write a certain section, try rubber duck debugging. Instead of trying to debug code, you are trying to debug your sentences. The essence of rubber duck debugging is to force yourself to explain the problem to someone else (in this case an inanimate rubber duck) and in the process, find a solution. or facing a difficult problem . Thinking Walks and Exercise . When you still feel stuck after a session of rubber duck debugging, try going on a short walk and let your subconscious do the work in the background. Working on something difficult? Go for a jog and clear you mind. Doing exercise regularly is also good for your health and subsequently, good for increasing productivity. . Run A Series of Seminars On The Topic . Not sure where I read this tip from… (maybe from this long seminar transcript?) This is a trick that some professors use apparently. Having trouble understanding the background needed to solve an important problem? Teach it, run seminars, write a blog about it, …. Doing so will force you to get to grips with the topic and express the concepts clearly. . Know When To Switch Writing Tasks . Inspired by this post and reframing it for writing tasks: . switching [writing tasks] too frequently (and giving up on promising ideas) is a more common failure mode than not switching enough. Often, while you’re engaged in the long slog towards getting your current idea to work, another promising idea will come along, and you’ll want to jump to that idea. If your idea is quick to try and the potential upside is large, then go ahead and do it. But more commonly, your initial results on the new idea will be disappointing, and it’ll take a more sustained effort to yield significant results. . Personal Development and Working On Important Problems . Don’t just write your thesis, take the time to learn something new and write about it. (or blog!) As this post says: . If you don’t allocate this time, then your knowledge is likely to plateau after you learn the basics that you need for your day-to-day work. It’s easy to settle into a comfort zone of methods you understand well—you may need to expend active effort to expand this zone. … One strategy, which I haven’t tried personally but makes a lot of sense upon reflection, is to devote some fixed time budget to trying out new ideas that diverge from your main line of work. Say, spend one day per week on something totally different from your main project. This would constitute a kind of epsilon-greedy exploration, and it would also help to broaden your knowledge. . If your research is in some niche application of machine learning, broaden your knowledge and read textbooks and papers outside your field. You never know when something your learned will spark a new idea. . Also, as a PhD student, you want to develop skills and solve important problems but it’s likely you don’t end up doing so for a few reasons according to this blog post. . Lack of self-development Many people don’t spend enough time on self-development. If you stop your development at the level which resulted in your first paper, it’s unlikely you’ll solve any major problems. . | The treadmill of small problems Social factors such as the need to publish, get grants, and so on, encourage people to work only on unimportant problems, without addressing the important problems. This can be a difficult treadmill to get off. . | The intimidation factor Even if people have spent enough time on self-development that they have a realistic chance of attacking big problems, they still may not. The reason is that they have a fear of working on something unsuccessfully. . | … worth thinking about. . Be Inspired . /u/ryans01’s Four Rules of Life . This Reddit post sparked a reply which is summarised in the following image. . No More Zero Days A zero day is when you make no contribution to what you are doing. Make sure you every day a non-zero day. Didn’t do anything all day and it’s 11:58 pm? Write one sentence. One pushup. Read one page of that chapter. One. Because one is non zero. Turning into productivity ultimate master of the universe doesn’t happen from the vortex. It happens from a massive string of CONSISTENT NON ZEROS. . | Be Grateful To Your Three Selves Your three selves refer to the past you, the present you, and the future you. Be GRATEFUL to the past you for the positive things you’ve done. And do favours for the future you like you would for your best bro. Feeling like (redacted) today? Stop a second, think of a good decision you made yesterday. Salad and tuna instead of Big Mac? THANK YOU YOUNGER ME. Was yesterday a nonzero day because you wrote 200 words (hey, that’s all you could muster)? THANK YOU YOUNGER ME. Saved up some coin over time to buy that sweet thing you wanted? THANK YOU. Second part of the 3 me’s is you gotta do your future self a favour, just like you would for your best friend. Alarm clock goes off and bed is too comfy? (redacted) you present self, this one’s for my best friend, the future me. I’m up and going for a 5 km run (or 25 meter run, it’s gotta be non zero). MAKE SURE YOU THANK YOUR OLD SELF for rocking out at the end of every. single. thing. that makes your life better. The cycle of doing something for someone else (future you) and thanking someone for the good in your life (past you) is key to building gratitude and productivity. . | Forgive Yourself Maybe you got all the know-how, money, ability, strength and talent to do whatever is you wanna do. But let’s say you still didn’t do it. Now you’re giving yourself (redacted) for not doing what you need to, to be who you want to. Heads up champion, being disappointed in yourself causes you to be less productive. Tried your best to have a nonzero day yesterday and it failed? so what. I forgive you previous self. I forgive you. But today? Today is a nonzero masterpiece to the best of my ability for future self. This one’s for you future homies. Forgiveness man, use it. I forgive you. Say it out loud. . | Exercise and Books Pretty standard advice but when you exercise daily you actually get smarter. when you exercise you get high from endorphins (thanks body). when you exercise you clear your mind. when you exercise you are doing your future self a huge favour. Exercise is a leg on a three legged stool. Feel me? As for books, almost every thing we’ve all ever thought of, or felt, or gone through, or wanted, or wanted to know how to do, or whatever, has been figured out by someone else. Get some books max. . | Prolific Writers and Updating Readers/Supervisors . I like reading fantasy with well thought out magic systems and if we’re talking about prolific writers, one author to aspire to is Brandon Sanderson. This man is a machine and many of his fans joke that he’s cloned himself or is a robot because the sheer amount of well written output (and does a weekly podcast, updates fans on social media, goes on writing tours, and teaches a writing class at BYU). If you check out his website, he has progress bars for his works which is updated regularly! If you like fantasy, be sure to check this author out at the risk of being so engrossed by the story you spend the whole week reading instead of writing… . Warning: Patrick Rothfuss has some of the best writing I’ve ever read but the third book in the trilogy is nowhere near completion and, at the time of writing this blog post, I’ve been waiting 9 years since book 2 was published with no updates on progress - not even his editor knows. Do not do this to your supervisor! You do not have the same luxury as a PhD student or academic. . If you are avoiding your supervisor(s) when they are asking for a draft chapter, that is a sure sign you’re in deep waters. . Writing Excuses Podcast . I found this podcast on writing after following one of my favourite authors who is one of the hosts. From the homepage . Writing Excuses is a fast-paced, educational podcast for writers, by writers. . Although most of the content revolves around writing fiction, many of the writing tips and writing prompts are great to get you thinking and motivate you to write. Great for something to listen during your commute. . $~$ . I hope you enjoyed reading this and found it useful. To close, I will end on the same injunction used in Writing Excuses: . “You’re out of excuses. Now go write.” . $~$ . References . 1. Kearns, H., Gardiner, M. and Marshall, K., 2008. Innovation in PhD completion: The hardy shall succeed (and be happy!). Higher Education Research &amp; Development, 27(1), pp.77-89.↩ . 2. Greenberg, J., 1985. Unattainable Goal Choice as a Self‐Handicapping Strategy 1. Journal of Applied Social Psychology, 15(2), pp.140-152.↩ . 3. Gardiner, M., Kearns, H., Newsom, G., Dent, E.B., Newnham-Kanas, C., Irwin, J. and Schmitt, N., 2012. The ABCDE of writing: coaching high-quality high-quantity writing. International Coaching Psychology Review, 7(2), pp.237-249.↩ . 4. Covey, S.R. and Covey, S., 2020. The 7 habits of highly effective people. Simon &amp; Schuster.↩ .",
            "url": "https://yiweimao.github.io/blog/phd_writing/",
            "relUrl": "/phd_writing/",
            "date": " • Oct 16, 2020"
        }
        
    
  
    
  
    
  
    
  
    
        ,"post8": {
            "title": "Exploring an Open Source Hyperspectral Image Dataset",
            "content": "Introduction to Hyperspectral Imagery . Hyperspectral cameras simultaneously capture spatial and spectral information and produce hyperspectral image cubes. Each pixel in a hyperspectral image contains a spectrum from near infrared (NIR) to the visible; unlike cameras we are all familiar with on our phones which only capture red, green, and blue. These images are obtained by quick successive aquisitions of narrow contiguous spectral strips much like the line scanner in a photocopier. This is known as push broom scanning. Figure 1 shows an example of what a hyperspectral image cube looks like. . . Applications of hyperspectral imaging technology include object detection and classification by combining object shape and spectral signatures. It is the spectra that reveal chemical composition and provides a unique insight unobtainable from ordinary colour images. . In this blog post, we will explore and visualise some of the features of hyperspectral images. . Note: This was my first foray into the topic. . An Open Source Dataset . Despite the technology being available for the last few decades, the variety of open source datasets available is limited due to cost of equipment. . The data inspected here is from the HyperSpectral Salient Object Detection Dataset1. This dataset contains 60 hyperspectral images with 81 spectral channels in the visible range. The following table summarises the dataset format. . pd.DataFrame({&#39;Image Resolution&#39;:[&#39;1024 x 768 pixels&#39;], &#39;Wavelength Range&#39;:[&#39;380 -- 720 nm&#39;],&#39;Number of Spectral Channels&#39;:[81], &#39;File Format&#39;:[&#39;10 bit uint16, band interleaved by line&#39;]}) . Image Resolution Wavelength Range Number of Spectral Channels File Format . 0 1024 x 768 pixels | 380 -- 720 nm | 81 | 10 bit uint16, band interleaved by line | . Visualisation . Here is a subset of images in the sRGB format. These images contain scenes with vegetation, soil, water, sky, and signposts. However, they appear washed outalmost as if they&#39;ve been taken with a sepia effectand is definitely not colour accurate. . nrows = 3; ncols = 3; pic_num_offset = 40 color_img_name = iter( np.sort(os.listdir(&#39;color/&#39;))[pic_num_offset:] ) fig1, f1_ax = plt.subplots(ncols=ncols, nrows=nrows, constrained_layout=True) fig1.set_figheight(7.5); fig1.set_figwidth(9) for i in range(nrows): for j in range(ncols): ax = f1_ax[i,j] name = next(color_img_name) im = PIL.Image.open(&#39;color/&#39; + name) ax.imshow(im) ax.set_title(name); ax.set_xticks([]); ax.set_yticks([]) . To explore what&#39;s in these images, I have recorded the median pixel value for each spectrum channel and plotted them with an Altair tooltip. . source = df source = source.reset_index().melt(&#39;wavelength (nm)&#39;, var_name=&#39;file&#39;, value_name=&#39;median pixel intensity&#39;) source[&#39;wavelength (nm)&#39;] = [*x_pnts]*(nrows*ncols) # Create a selection that chooses the nearest point &amp; selects based on x-value nearest = alt.selection(type=&#39;single&#39;, nearest=True, on=&#39;mouseover&#39;, fields=[&#39;wavelength (nm)&#39;], empty=&#39;none&#39;) # The basic line line = alt.Chart(source).mark_line(interpolate=&#39;basis&#39;).encode( x=&#39;wavelength (nm):Q&#39;, y=&#39;median pixel intensity:Q&#39;, color=&#39;file:N&#39;) # Transparent selectors across the chart. This is what tells us # the x-value of the cursor selectors = alt.Chart(source).mark_point().encode( x=&#39;wavelength (nm):Q&#39;,opacity=alt.value(0),).add_selection(nearest) # Draw points on the line, and highlight based on selection points = line.mark_point().encode( opacity=alt.condition(nearest, alt.value(1), alt.value(0)) ) # Draw text labels near the points, and highlight based on selection text = line.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=alt.condition(nearest, &#39;median pixel intensity:Q&#39;, alt.value(&#39; &#39;)) ) # Draw a rule at the location of the selection rules = alt.Chart(source).mark_rule(color=&#39;gray&#39;).encode( x=&#39;wavelength (nm):Q&#39;,).transform_filter(nearest) # Put the five layers into a chart and bind the data alt.layer(line, selectors, points, rules, text).properties(width=600, height=300) . We can see that there is a trend common to all images with a peak at around 500--600 nm, a trough at 675 nm, and a few peaks at 695 nm and 720 nm. File 0065.mat has a higher median pixel value over all channels because most of the is picture of a sunny sky. . Classification Strategy without Spatial Information . By taking the median pixel value over every channel, we have effectively removed any spatial information but we can still tell a whole lot about what&#39;s in an image. For example, the median information we extracted can be thrown into a decision tree or random forest for classification (assuming we have some labels for soil, vegetation, sky, and urban that describe what&#39;s in the image). . At first glance we can already tell that if the median pixel value in the blue is high, then the image is sky. . You can begin to see how powerful the predictive power of a hyperspectral image classifier can become when we are able to combine both spatial and spectral information. . Conclusion . In this blog post, we explored one of the few open source hyperspectral image datasets available and outlined some applications. We discovered that it is possible to glean information from looking at only the frequency channels. We also discussed how the dataset is specific to the particular hyperspectral camera used and the lack of white balancing. . References . 1. Imamoglu, Nevrez, et al. &quot;Hyperspectral image dataset for benchmarking on salient object detection.&quot; 2018 Tenth International Conference on Quality of Multimedia Experience (QoMEX). IEEE, 2018.↩ .",
            "url": "https://yiweimao.github.io/blog/exploring_hyperspectral/",
            "relUrl": "/exploring_hyperspectral/",
            "date": " • Apr 18, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Understanding GPU Tessellation",
            "content": "Understanding Tessellation . What is Tessellation . Tessellation is a feature that converts a low-detailed surface patch to a higher detailed surface patch dynamically on the Graphics Processing Unit (GPU). Using a low resolution model with a few polygons, tessellation makes rendering high levels of detail possible by subdividing each patch into smaller primitives. . This blog post will outline how tessellation fits into the graphics pipeline and how to understand the various parameters needed for tessellation including tessellation factors, partition type, and output domain. Finally, I provide code to run a tessellation visualisation including an interactive widget so you can experiment with the various parameters. . Benefits of Tessellation . According to DX11 Tess Docs, the benefits are: . Lower memory and bandwidth requirements. | Allows continuous or view dependent details to be calculated on the fly. | Improves performance by performing expensive computations at lower frequency (doing calculations on a lower-detail model). For instance, calculations for collision detection or soft body dynamics. | A graphics pipeline is a series of functions that transforms inputs (primitive data such as points, lines or triangles) into outputs for rendering. Primitives refer to the atomic or irreducible objects the system can handle. To add tessellation, the graphics pipeline requires three new stages. . Pipeline Stages . The DX11 graphics pipeline consists of a series of stages shown in Figure 1. . . A description of each stage is summarised in this itemised list: . Input-Assembler Stage Read primitive data and assemble them into primitives for other stages (e.g. line lists, and triangle strips) . | Vertex Shader Stage Processes the assembled vertices and applies operations such as transformations, skinning, morphing, and per-vertex lighting. &gt; Single input vertex and single output vertex. . | Tessellation Stages Breaks up a patch of control points into smaller primitives and thus create higher detailed features. . | Geometry Shader Stage Operates on vertices and can generate output vertices . | Stream-Output Stage Continuously output vertex data from geometry shader to buffers . | Rasterizer Stage Converts primitives into a raster image for displaying. . | Pixel Shader Stage Operate on a per-pixel level and can change lighting, etc using the available constant variables, texture data, and others. . | Output-Merger Stage Generates the final rendered pixel colour, determines which pixels are visible and blending pixel colours. . | The tessellation stages consistes of three new stages which are: . Hull-Shader (HS) Stage Computes patch constants (such as tessellation factors) and other parameters for the tessellation stage. Performs any special transformations on the input patch data. . | Tessellator (Tess) Stage A fixed function that partitions a geometry into smaller primitives and outputs u,v coordinates of the vertices and assembly order. . | Domain-Shader (DS) Stage Calculates vertex position that corresponds to the each u,v coordinate. . | . OpenGL uses the names Tessellation Control Shader, Primitive Generator, and Tessellation Evaulation Shader to refer to the HS, Tess, and DS respectively. . As an aside, the word “shader” refers to an operation that transforms four input numbers into four output numbers. Historically, a shader was used to change the brightness of pixels (RGBA values) but now encompasses more general operations and the name has stuck. . OpenGL and DX using different winding order. The winding order determines the order the vertex stream arrives and this information can be used to check if a patch is facing the screen or away from the screen. . The parameters for the Tessellator stage are: winding order, tessellation factors, partitioning type, and primitive type. . Tessellation Factors . Tessellation factors specify how much each edge needs to be partitioned. For example, a tessellation factor of 1 means no partitioning and a tessellation factor of $n$ means partition that edge into $n$ parts. There are two types, inner and outer factors. . Inner Factors . The inner factor specifies how the interior is partitioned. When this factor is even, the centre of the output domain is a degenerate point. For example, an inner factor of 1 means no inner partitioning and a tessellation factor of $n$ partitions the output domain into $ text{floor}(n/2)$ smaller versions of the output domain shape. . . Outer Factors . This specifies how the outer edges of the output domain are partitioned. . . Partition Type . Integer . Integer refers to what values the tessellation factors can take. In this case, the valid values are $1,2,…,64$. . Power of 2 . Same as integer but the valid tessellation factors are powers of two. That is $2^0,2^1,…,2^5,2^6$ with the maximum tessellation factor of 64. . Fractional . Fractional partitioning allows for a mix of normal and small segments and these correspond to the integer value and fractional value of a tessellation factor. Since each control patch consists of many primitives that can share sides and have a shared tessellation factor, the output primitives need to be symmetric. This symmetry brings about two cases which differ in the location where new verticies are generated: an odd and even parity. . Odd . New vertices are generated from the corners. . The number of segments on an edge is always odd so a tessellation factor of 5 would give five equally spaced segments. If the tessellation factor was 5.1, there would be seven segments, two of which are small and near a corner. . . Even . New vertices are generated from the midpoint. . The number of segmenst on an edge is always even so a tessellation factor of 4 would give four equally spaced segments and if the tessellation factor was 4.1, there would be six segments, two of which are small and near the midpoint. . . Output Domains . We have already seen what the three types of output domain are: isoline, triangle, and quadrilateral. In the case of a quadrilateral, the output primitives can be triangles or quadrilaterals. . Isoline . For an isoline, the outer tessellation factor is rounded up to the next integer and fractional partitioning only affects the inner tessellation factor. The number of parallel lines is given by the outer tessellation factor while the partitioning of each segment is described by the inner tessellation factor. The outer and inner factor are also known as line density and line detail. . Triangle . For a triangle, barycentric coordinates represent a 2D position using three numbers ($ alpha, beta, gamma$) with the condition that $ alpha+ beta+ gamma = 1$. This means there are only two free parameters and is directly related to u, v coordinates using a coordinate transform. Barycentric coordinates allow the same partitioning strategy to be applied regardless of being a Triangle or Quadrilateral. . Barycentric Coordinates . Barycentric coordinates can be understood as a ratio of areas with $A$ representing the total area. . α=AA/A alpha = A_A/Aα=AA​/A . β=AB/A beta = A_B/Aβ=AB​/A . γ=AC/A gamma = A_C/Aγ=AC​/A . The coordinates ($ alpha, beta, gamma$) must sum to unity because the sum of each component subtriangle area must equal the total area of the original triangle. Furthermore, the coordinates are between 0 and 1 because the point $ mathbf{x}$ defines a point within the large triangle. If any of the coordinates are negative or greater than 1, this would corespond to a point outside the allowable triangle. . $ mathbf{b-a}$ and $ mathbf{c-a}$ span an linearly independent vector space and are the basis vectors for a triangle with origin $ mathbf{a}$. . x=a+β(b−a)+γ(c−a) mathbf{x} = mathbf{a} + beta( mathbf{b-a} ) + gamma( mathbf{c-a})x=a+β(b−a)+γ(c−a) . =(1−β−γ)a+βb+γc= (1- beta - gamma) mathbf{a} + beta mathbf{b} + gamma mathbf{c}=(1−β−γ)a+βb+γc . =αa+βb+γc= alpha mathbf{a} + beta mathbf{b} + gamma mathbf{c}=αa+βb+γc . So the “colour” coordinate at point $ mathbf{x}$ is some linear combination of the triangle vertices. . . The DX11 Tessellation spec always returns two values: $u$ and $v$, to the third parameter needs to be computed using the unity condition of Barycentric coordinates - that is, $w=1-u-v$. . Quadrilateral . For the quad output domain, the coordinates $u$, and $v$ represent the familar $x$ and $y$ axis of Cartesian space. . Visualisation . I have taken the DX11 Spec for tessellation1, compiled it and made a python script2 to run the C++ code with customisable parameters. You can play around with the tessellation factors and output domain type and get a feel for how it all works. The steps are: . git clone https://github.com/YiweiMao/tessDX cd tessDX/ make . Then in a python shell, execute the following: . from pytess import * # for one instance of tessellation # if len(tfs)==2, isoline. elif len(tfs)==4, tri. elif len(tfs)==6, quad. Tessellator(partition=PART_INT,outputPrim=OUTPUT_TRIANGLE_CW,tfs=[1,2,3,4]).doTess() # for interactivity. Change the sliders to see the updated tessellation interact(showTess,partition=(0,3,1),outputPrim=(0,3,1),outTF0=(1,64,0.1),outTF1=(-1,64,0.1), outTF2=(-1,64,0.01),outTF3=(-1,64,0.1),inTF0=(1,64,0.1),inTF1=(-1,64,0.1)) . . Conclusion . Tessellation is a useful GPU feature that can dynamically increase the level of detail on a surface for rendering. We explored how the fixed function tessellator stage fits into the graphics pipeline and what the various parameters mean. We learned how to interpret inner and outer tessellation factors, integer and even/odd fractional partitioning, and isoline/triangle/quadrilateral output domains. Most importantly, I leave you with a tool which you can use to visualise the tessellated output for a given set of parameters. . References . https://github.com/microsoft/DirectX-Specs/tree/master/d3d/archive/images/d3d11 &#8617; . | https://github.com/YiweiMao/tessDX &#8617; . |",
            "url": "https://yiweimao.github.io/blog/tessellation/",
            "relUrl": "/tessellation/",
            "date": " • Feb 26, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Hamming Code for Error Correction",
            "content": "Introduction . Digital communication relies on encoded bits that are transmitted across noisy channels which inevitably suffer from errors. This can be a huge problem for systems that cannot deal with errors. An example of this is interplanetary satellites with limited bandwidth and long communication time delays - by the time the effects of an error is detected, it may be too late to send correction commands. Such systems need to be able to detect errors and correct them if possible. A real application of error correcting codes was on the Mariner 9 mission which required pictures to be sent back from Mars1 (this used an error correcting Hadamard code). . This blog will investigate the encoder and decoder stage - how digital information is encoded with error correcting information using the power of numbers. The idea of redundancy and parity is introduced before the Hamming code is described. An example using Hamming(7,4) is given followed by the notion of the Hamming distance. The blog post will conclude with a brief outline of developments since Hamming’s original paper in 1950. . Redundancy . Let the bit length of a message be denoted by $m$. This message can represent $2^m$ unique symbols or characters. If a single bit within the $m$ length bit string is flipped, a different symbol is reconstructed and there is no way of knowing if an error occurred. In order to encode error detection and correction, additional redundant bits are needed. Let the bit length of the redundant bits be denoted by $k$ so the total length of the bits that need to be transmitted is $n=m+k$. . The redundancy factor $R$ is defined to be R:=nmR := frac{n}{m}R:=mn​ and this measures the efficiency of the encoding. Redundancy is also a method of generating sparse decompositions of signals and this is known as compressed sensing. This method has applications in computed tomography because image reconstruction can be formulated as a compressed sensing problem2. . A core part of encoding information into the redundant bits is the idea of parity. . Parity . In the context of binary numbers, parity refers to the number of 1’s that appear in the binary representation. Parity can be encoded by a single bit, for instance the $n^{th}$ bit $b_n$, so that the whole bit string $b_n b_{n-1} dots b_2 b_1$ contains an even number of 1’s. The parity bit is set to 1 if there are an odd number of 1s in the preceding $n-1$ bits, and set to 0 otherwise: . bn=∑i=1n−1bi where addition is done modulo 2.b_n = sum_{i=1}^{n-1} b_i quad text{ where addition is done modulo 2.}bn​=i=1∑n−1​bi​ where addition is done modulo 2. . This allows for a single bit error to be detected because if there is a single bit flip, there is no longer an even number of 1’s in the bit string. However, double bit errors cannot be detected. The next step is to add error correcting capability and this is given by the Hamming code (Hamming 1950). The following section will introduce the Hamming(7,4) code which has $n=7$ and $m=4$ (this will have $k=n-m=3$ redundant bits). . Hamming Code . A Hamming code is constructed by assigning the $k$ redundant bits as check bits over select $m$ information bits. If the check bit received in an $n$ bit string matches the computed parity, then a 0 is recorded, and if it disagrees, a 1 is recorded. The sequence of check bits given by $ mathrm{c_k…c_1}$ provides the position of a single error and is called the checking number. If the checking number is zero, then no error was detected. The checking number is required to represent $m+k+1$ combinations giving a condition 2k≥m+k+1  ⟹  2m≤2n/(n+1).2^k geq m+ k + 1 implies 2^m leq 2^n/(n+1).2k≥m+k+1⟹2m≤2n/(n+1). One can check this condition by substituting $n = m+k$. . For the check number to represent the binary number of the error position, the check bits are placed in positions $1,2,4,8,…,2^{k-1}$. The $i^{th}$ check bit records the parity of bit positions which have a 1 in the $i^{th}$ position in the binary representation So the first check bit will have the parity for bit positions: 1,3,5,7,… which have a 1 in the 1st position. The second check bit will have the parity for bit positions: 2,3,6,7,… which have a 1 in the 2nd position. This is summarised in this Table: . Check bit Binary Check bit 2 Binary Check bit 3 Binary . 1 | 1 | 2 | 10 | 4 | 100 | . 3 | 11 | 3 | 11 | 5 | 101 | . 5 | 101 | 6 | 110 | 6 | 110 | . 7 | 111 | 7 | 111 | 7 | 111 | . 9 | 1001 | 10 | 1010 | 12 | 1100 | . 11 | 1011 | 11 | 1011 | 13 | 1101 | . 13 | 1101 | 14 | 1110 | 14 | 1110 | . 15 | 1111 | 15 | 1111 | 15 | 1111 | . Error Detection and Correction Example . Consider a 7 bit string $ mathrm{b_7b_6b_5b_4b_3b_2b_1}= texttt{0111100}$ which encodes a bit string ${ mathrm{m_4 m_3 m_2 m_1} = texttt{b1011} = 11}$ and check bits $ mathrm{k_3 k_2 k_1} = texttt{b001}$. This is the Hamming(7,4) code meaning $n=7$ and $m=4$. . The original bit string: . Suppose the bit $ mathrm{m_2}$ in position 5 has an error so instead of the original 1, it is now 0. The checking number $ mathrm{c_3 c_2 c_1}$ can be computed. In Figure 1, the first parity counts an odd number of 1’s in positions 1,3,5, and 7 so $c_1=1$. . . Next, the second parity counts an even number of 1’s in the positions 2,3,6, and 7 so $c_2=0$. . . The third parity counts an odd number of 1’s in the positions 4,5,6, and 7 so $c_3=1$. . . This gives a checking number $c_3 c_2 c_1= texttt{101}$ which is position 5. Therefore, there is an error in position 5 which can be corrected by converting the 0 into a 1. . Another example of a Hamming code is triple repetition. Each bit is sent three times and majority rules is applied to decode the message. This is Hamming(3,1) and uses 2 parity bits. Using this code, single errors can be corrected or double errors can be detected but not corrected. This makes sense because if a single bit is flipped, the majority rule recovers the correct bit. However, if two bits are flipped, these errors can be detected but if correction is applied, the wrong bit will be reconstructed. The (7,4) code Hamming introduced in his paper can be extended to (8,4) allowing for single error correction and double error detection. . Single Error Correction plus Double Error Detection . Double error detection can be added by using another bit that represents the parity for positions, that when expressed in binary, have a 1 in the $4^{th}$ position. Then there exists three cases with the first being all parity checks pass. The second case is when there is a single error and the last parity check fails. The checking number then gives the position of the error with zero now meaning the error is in the last check position. The last case is then the last parity check is satisfied but the checking number indicates that there is an error. In this case, there is a double error. . Hamming (1950) 3 gives a way of determining what actions can be done (error detection or error correction) by introducing a metric. . Hamming Distance . The distance $D$ between two bit strings ${x}$ and ${y}$ is given by the Hamming distance. . The Hamming distance is given by the number of positions (or coordinates) where two bit strings differ. . This definition satisfies the conditions for a metric: begin{split} D(x,y) = 0 quad &amp; text{iff } x=y D(x,y) = D(y,x) &gt; 0 quad &amp; text{if } x neq y D(x,y) + D(y,z) geq D(x,z) quad &amp; text{triangle inequality.} end{split} . Imagine each code being encoded by corners in a $2^n$ hypercube, then if each code has a distance of $r$ between a neighbouring code, the codes lie on the surface of a $r+1$ sphere centered on some origin. For example, a $r=2$ code with $n=3$ can be: 000, 011, 101, 110. Each code is a distance 2 apart and sit on the corners of a cube as depicted in Figure 5. . . When there is a distance of 2 between the codes, then a single error will convert a point on the cube to a coordinate that is meaningless. This corresponds to single error detection. However, this error cannot be corrected since the false code is equidistant to a number of other true codes. A 3 distance code for $n = 3$ can be: 000, and 111. This is shown in Figure 6. . . When there is a single error, the error can be corrected because the false code will be closer to the correct code than the others. A more detailed list of actions is summarised in the following table. . Minimum Hamming Distance Available Actions                                                                                           . 1 | Unique. No redundancy. | . 2 | Single error detection | . 3 | Single error correction or Double error detection | . 4 | Single error correction + Double error detection or | .   | Triple error detection | . 5 | Double error correction or | .   | Single error correction + Triple error detection or | .   | Quadruple error detection | . From the table above, it can be seen that an extra Hamming distance of 2 is needed to correct an additional error and an extra Hamming distance of 1 is needed to detect an additional error. . Developments in Error Correction Codes . More general codes can be made by constructing a parity check matrix which contains error correction abilities based on linear dependent columns4. From there, the mapping between messages and code can be found using a generator matrix computed from the parity matrix5. The example shown in this blog post relied on operations on a Galois (or finite) field with characteristic 2 (so addition and multiplication is done modulo 2). Other fields can also be used such $ mathbf{F}_{11}$ which is implemented in the User Datagram Protocol (UDP). UDP can also fix erasures - when bits are lost rather than flipped6. There is also a family of Hamming codes which include extensions and shortenings that allow Hamming codes to perform better or improve the redundancy factor7. . Multiple error correction codes can be done using Reed-Solomon (RS)8 and Bose-Chaudhuri-Hocquenghem (BCH)9 which can be hard to decode because the number of errors is not known beforehand. By using primitive polynomials for the Galois field, the coding can be done on Linear Feedback Shift Registers (LFSR)10. The location of errors can be found by solving for the roots of an error locator polynomial11 given by the Massey algorithm12. Roots of the locator polynomial are found using Chien search and the Forney formula gives a way of computing the values for erasures13. Following this, Sugiyama invented a method for decoding Goppa codes based on the Euclidean algorithm and Kerlekamp’s key equation, forgoing the need to find the locator polynomial14. Other decoding methods include the Discrete Fourier Transform (DFT)15. . Many different types of codes exist including cyclic codes and convolutional or continuous codes. For instance, the Chinese remainder theorem is used to decode Fire codes16 which is a type of cyclic code. Convolutional codes can be decoded with the Viterbi algorithm17. Applications of error correcting coding and decoding extend to public key encryption18 amongst others. . Conclusion . The main ideas of error correction codes using the Hamming code were explored with the help of an example. Hamming distance was introduced which gives an indication of what actions can be done depending on the minimum Hamming distance. Finally, a brief overview of developments since Hamming’s paper was given. . References . Brian J Thompson, Robert Rennie Shannon, et al. Space Optics: Proceedings of the Ninth International Congress of the International Commission for Optics (ico IX), volume 9. National Academies, 1974. &#8617; . | Hengyong Yu and Ge Wang. Compressed sensing based interior tomography. Physics in medicine &amp; biology, 54(9):2791, 2009. &#8617; . | Richard W Hamming. Error detecting and error correcting codes. The Bell system technical journal, 29(2):147–160, 1950. &#8617; . | Robert Gallager. Low-density parity-check codes. IRE Transactions on information theory, 8(1):21–28, 1962. &#8617; . | David JC MacKay and Radford M Neal. Near shannon limit performance of low density parity check codes. Electronics letters, 32(18):1645–1646, 1996. &#8617; . | Jon Postel. User datagram protocol. Isi, 1980. &#8617; . | Victor K Wei. Generalized hamming weights for linear codes. IEEE Transactions on information theory, 37(5):1412–1418, 1991. &#8617; . | Stephen B Wicker and Vijay K Bhargava. Reed-Solomon codes and their applications. John Wiley &amp; Sons, 1999. &#8617; . | Robert Chien. Cyclic decoding procedures for bose-chaudhuri-hocquenghem codes. IEEE Transactions on information theory, 10(4):357–363, 1964.9 &#8617; . | Sybille Hellebrand, Janusz Rajski, Steffen Tarnick, Srikanth Venkataraman, and Bernard Courtois. Built-in test for circuits with scan based on reseeding of multiple-polynomial linear feedback shift registers. IEEE Transactions on Computers, 44(2):223–233, 1995. &#8617; . | T-K Truong, J-H Jeng, and Irving S Reed. Fast algorithm for computing the roots of error locator polynomials up to degree 11 in reed-solomon decoders. IEEE Transactions on Communications, 49(5):779–783, 2001. &#8617; . | G-L Feng and Kenneth K Tzeng. A generalization of the berlekamp-massey algorithm for multisequence shift-register synthesis with applications to decoding cyclic codes. IEEE Transactions on Information Theory, 37(5):1274–1287, 1991. &#8617; . | Douglas A Leonard. A generalized forney formula for algebraic-geometric codes. IEEE Transactions on Information Theory, 42(4):1263–1268, 1996. &#8617; . | Yasuo Sugiyama, Masao Kasahara, Shigeichi Hirasawa, and Toshihiko Namekawa. A method for solving key equation for decoding goppa codes. Information and Control, 27(1):87–99, 1975. &#8617; . | Richard E. Blahut. Transform techniques for error control codes. IBM Journal of Research and development, 23(3):299–315, 1979. &#8617; . | R Chien. Burst-correcting codes with high-speed decoding. IEEE Transactions on Information Theory, 15(1):109–113, 1969. &#8617; . | G David Forney. The viterbi algorithm. Proceedings of the IEEE, 61(3):268–278, 1973. &#8617; . | Yuan Xing Li, Robert H Deng, and Xin Mei Wang. On the equivalence of mceliece’s and niederreiter’s public-key cryptosystems. IEEE Transactions on Information Theory, 40(1):271–273, 1994. &#8617; . |",
            "url": "https://yiweimao.github.io/blog/hamming/",
            "relUrl": "/hamming/",
            "date": " • Feb 15, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am doing my PhD at the University of Sydney working on hyperspectral remote sensing. My interests lie in computer vision and machine learning. I am also a musician in my spare time playing the Euphonium in the Parramatta Salvation Army Brass Band. . Experience . ARC Training Centre for CubeSats, UAVs &amp; Their Applications PhD internship (2020 – Current) . | Imagination Technologies Internship (2019 – 2020) . | University of Sydney Casual Academic Tutor (2018 – Current) . | CSIRO Astronomy and Space Science Summer Vacation Research Student (2017 – 2018) . | Sydney Academy of Chess Chess Coach (2015 – 2017) . | University . I studied Mechatronics Engineering and Advanced Science (majored in Physics and Maths) at the University of Sydney. . Academic Papers . Year Paper Title                                                                                                                                       . 2020 | TweetS@: A 3D Printed Tweeting CubeSat with a Neural Network Sun Sensor | .   | Australian Space Research Conference 2019 Proceedings | . Contact Details . Email: ewaymao@gmail.com Personal blog: https://yiweimao.github.io/blog/ .",
          "url": "https://yiweimao.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://yiweimao.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}