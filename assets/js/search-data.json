{
  
    
        "post0": {
            "title": "Introduction_to_tessellation",
            "content": "Introduction to Tessellation . An introduction to tessellation. Python code is provided to run the visualisation. . Introduction to Tessellation What is Tessellation | Benefits of Tessellation | Pipeline Stages | Tessellation Factors Inner Factors | Outer Factors | | Partition Type Integer Power of 2 | | Fractional Odd | Even | | | Output Domains Isoline | Triangle Barycentric Coordinates | | Quadrilateral | | Visualisation | Conclusion | | References | What is Tessellation . Tessellation is a feature that converts a low-detailed surface patch to a higher detailed surface patch dynamically on the Graphics Processing Unit (GPU). Using a low resolution model with a few polygons, tessellation makes rendering high levels of detail possible by subdividing each patch into smaller primitives. . This blog post will outline how tessellation fits into the graphics pipeline and how to understand the various parameters needed for tessellation including tessellation factors, partition type, and output domain. Finally, I provide code to run a tessellation visualisation including an interactive widget so you can experiment with the various parameters. . Benefits of Tessellation . According to DX11 Tess Docs, the benefits are: . Lower memory and bandwidth requirements. | Allows continuous or view dependent details to be calculated on the fly. | Improves performance by performing expensive computations at lower frequency (doing calculations on a lower-detail model). For instance, calculations for collision detection or soft body dynamics. | A graphics pipeline is a series of functions that transforms inputs (primitive data such as points, lines or triangles) into outputs for rendering. Primitives refer to the atomic or irreducible objects the system can handle. To add tessellation, the graphics pipeline requires three new stages. . Pipeline Stages . The DX11 graphics pipeline consists of a series of stages shown in Figure 1. . . A description of each stage is summarised in this itemised list: . Input-Assembler Stage Read primitive data and assemble them into primitives for other stages (e.g. line lists, and triangle strips) . | Vertex Shader Stage Processes the assembled vertices and applies operations such as transformations, skinning, morphing, and per-vertex lighting. &gt; Single input vertex and single output vertex. . | Tessellation Stages Breaks up a patch of control points into smaller primitives and thus create higher detailed features. . | Geometry Shader Stage Operates on vertices and can generate output vertices . | Stream-Output Stage Continuously output vertex data from geometry shader to buffers . | Rasterizer Stage Converts primitives into a raster image for displaying. . | Pixel Shader Stage Operate on a per-pixel level and can change lighting, etc using the available constant variables, texture data, and others. . | Output-Merger Stage Generates the final rendered pixel colour, determines which pixels are visible and blending pixel colours. . | The tessellation stages consistes of three new stages which are: . Hull-Shader (HS) Stage Computes patch constants (such as tessellation factors) and other parameters for the tessellation stage. Performs any special transformations on the input patch data. . | Tessellator (Tess) Stage A fixed function that partitions a geometry into smaller primitives and outputs u,v coordinates of the vertices and assembly order. . | Domain-Shader (DS) Stage Calculates vertex position that corresponds to the each u,v coordinate. . | . OpenGL uses the names Tessellation Control Shader, Primitive Generator, and Tessellation Evaulation Shader to refer to the HS, Tess, and DS respectively. . As an aside, the word “shader” refers to an operation that transforms four input numbers into four output numbers. Historically, a shader was used to change the brightness of pixels (RGBA values) but now encompasses more general operations and the name has stuck. . OpenGL and DX using different winding order. The winding order determines the order the vertex stream arrives and this information can be used to check if a patch is facing the screen or away from the screen. . The parameters for the Tessellator stage are: winding order, tessellation factors, partitioning type, and primitive type. . Tessellation Factors . Tessellation factors specify how much each edge needs to be partitioned. For example, a tessellation factor of 1 means no partitioning and a tessellation factor of $n$ means partition that edge into $n$ parts. There are two types, inner and outer factors. . Inner Factors . The inner factor specifies how the interior is partitioned. When this factor is even, the centre of the output domain is a degenerate point. For example, an inner factor of 1 means no inner partitioning and a tessellation factor of $n$ partitions the output domain into $ text{floor}(n/2)$ smaller versions of the output domain shape. . . Outer Factors . This specifies how the outer edges of the output domain are partitioned. . . Partition Type . Integer . Integer refers to what values the tessellation factors can take. In this case, the valid values are $1,2,…,64$. . Power of 2 . Same as integer but the valid tessellation factors are powers of two. That is $2^0,2^1,…,2^5,2^6$ with the maximum tessellation factor of 64. . Fractional . Fractional partitioning allows for a mix of normal and small segments and these correspond to the integer value and fractional value of a tessellation factor. Since each control patch consists of many primitives that can share sides and have a shared tessellation factor, the output primitives need to be symmetric. This symmetry brings about two cases which differ in the location where new verticies are generated: an odd and even parity. . Odd . New vertices are generated from the corners. . The number of segments on an edge is always odd so a tessellation factor of 5 would give five equally spaced segments. If the tessellation factor was 5.1, there would be seven segments, two of which are small and near a corner. . . Even . New vertices are generated from the midpoint. . The number of segmenst on an edge is always even so a tessellation factor of 4 would give four equally spaced segments and if the tessellation factor was 4.1, there would be six segments, two of which are small and near the midpoint. . . Output Domains . We have already seen what the three types of output domain are: isoline, triangle, and quadrilateral. In the case of a quadrilateral, the output primitives can be triangles or quadrilaterals. . Isoline . For an isoline, the outer tessellation factor is rounded up to the next integer and fractional partitioning only affects the inner tessellation factor. The number of parallel lines is given by the outer tessellation factor while the partitioning of each segment is described by the inner tessellation factor. The outer and inner factor are also known as line density and line detail. . Triangle . For a triangle, barycentric coordinates represent a 2D position using three numbers ($ alpha, beta, gamma$) with the condition that $ alpha+ beta+ gamma = 1$. This means there are only two free parameters and is directly related to u, v coordinates using a coordinate transform. Barycentric coordinates allow the same partitioning strategy to be applied regardless of being a Triangle or Quadrilateral. . Barycentric Coordinates . Barycentric coordinates can be understood as a ratio of areas with $A$ representing the total area. . α=AA/A alpha = A_A/Aα=AA​/A . β=AB/A beta = A_B/Aβ=AB​/A . γ=AC/A gamma = A_C/Aγ=AC​/A . The coordinates ($ alpha, beta, gamma$) must sum to unity because the sum of each component subtriangle area must equal the total area of the original triangle. Furthermore, the coordinates are between 0 and 1 because the point $ mathbf{x}$ defines a point within the large triangle. If any of the coordinates are negative or greater than 1, this would corespond to a point outside the allowable triangle. . $ mathbf{b-a}$ and $ mathbf{c-a}$ span an linearly independent vector space and are the basis vectors for a triangle with origin $ mathbf{a}$. . x=a+β(b−a)+γ(c−a) mathbf{x} = mathbf{a} + beta( mathbf{b-a} ) + gamma( mathbf{c-a})x=a+β(b−a)+γ(c−a) . =(1−β−γ)a+βb+γc= (1- beta - gamma) mathbf{a} + beta mathbf{b} + gamma mathbf{c}=(1−β−γ)a+βb+γc . =αa+βb+γc= alpha mathbf{a} + beta mathbf{b} + gamma mathbf{c}=αa+βb+γc . So the “colour” coordinate at point $ mathbf{x}$ is some linear combination of the triangle vertices. . . The DX11 Tessellation spec always returns two values: $u$ and $v$, to the third parameter needs to be computed using the unity condition of Barycentric coordinates - that is, $w=1-u-v$. . Quadrilateral . For the quad output domain, the coordinates $u$, and $v$ represent the familar $x$ and $y$ axis of Cartesian space. . Visualisation . I have taken the DX11 Spec for tessellation1, compiled it and made a python script2 to run the C++ code with customisable parameters. You can play around with the tessellation factors and output domain type and get a feel for how it all works. The steps are: . git clone https://github.com/YiweiMao/tessDX cd tessDX/ make . Then in a python shell, execute the following: . from pytess import * # for one instance of tessellation # if len(tfs)==2, isoline. elif len(tfs)==4, tri. elif len(tfs)==6, quad. Tessellator(partition=PART_INT,outputPrim=OUTPUT_TRIANGLE_CW,tfs=[1,2,3,4]).doTess() # for interactivity. Change the sliders to see the updated tessellation interact(showTess,partition=(0,3,1),outputPrim=(0,3,1),outTF0=(1,64,0.1),outTF1=(-1,64,0.1), outTF2=(-1,64,0.01),outTF3=(-1,64,0.1),inTF0=(1,64,0.1),inTF1=(-1,64,0.1)) . . Conclusion . Tessellation is a useful GPU feature that can dynamically increase the level of detail on a surface for rendering. We explored how the fixed function tessellator stage fits into the graphics pipeline and what the various parameters mean. We learned how to interpret inner and outer tessellation factors, integer and even/odd fractional partitioning, and isoline/triangle/quadrilateral output domains. Most importantly, I leave you with a tool which you can use to visualise the tessellated output for a given set of parameters. . References . https://github.com/microsoft/DirectX-Specs/tree/master/d3d/archive/images/d3d11 &#8617; . | https://github.com/YiweiMao/tessDX &#8617; . |",
            "url": "https://yiweimao.github.io/blog/2020/02/26/introduction_to_tessellation.html",
            "relUrl": "/2020/02/26/introduction_to_tessellation.html",
            "date": " • Feb 26, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://yiweimao.github.io/blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Error_correction",
            "content": "Hamming Code for Error Correction . A walkthrough on Hamming codes. . Hamming Code for Error Correction | Introduction | Redundancy | Parity | Hamming Code Error Detection and Correction Example | Single Error Correction plus Double Error Detection | | Hamming Distance | Developments in Error Correction Codes | Conclusion | References | Introduction . Digital communication relies on encoded bits that are transmitted across noisy channels which inevitably suffer from errors. This can be a huge problem for systems that cannot deal with errors. An example of this is interplanetary satellites with limited bandwidth and long communication time delays - by the time the effects of an error is detected, it may be too late to send correction commands. Such systems need to be able to detect errors and correct them if possible. A real application of error correcting codes was on the Mariner 9 mission which required pictures to be sent back from Mars1 (this used an error correcting Hadamard code). . This blog will investigate the encoder and decoder stage - how digital information is encoded with error correcting information using the power of numbers. The idea of redundancy and parity is introduced before the Hamming code is described. An example using Hamming(7,4) is given followed by the notion of the Hamming distance. The blog post will conclude with a brief outline of developments since Hamming’s original paper in 1950. . Redundancy . Let the bit length of a message be denoted by $m$. This message can represent $2^m$ unique symbols or characters. If a single bit within the $m$ length bit string is flipped, a different symbol is reconstructed and there is no way of knowing if an error occurred. In order to encode error detection and correction, additional redundant bits are needed. Let the bit length of the redundant bits be denoted by $k$ so the total length of the bits that need to be transmitted is $n=m+k$. . The redundancy factor $R$ is defined to be R:=nmR := frac{n}{m}R:=mn​ and this measures the efficiency of the encoding. Redundancy is also a method of generating sparse decompositions of signals and this is known as compressed sensing. This method has applications in computed tomography because image reconstruction can be formulated as a compressed sensing problem2. . A core part of encoding information into the redundant bits is the idea of parity. . Parity . In the context of binary numbers, parity refers to the number of 1’s that appear in the binary representation. Parity can be encoded by a single bit, for instance the $n^{th}$ bit $b_n$, so that the whole bit string $b_n b_{n-1} dots b_2 b_1$ contains an even number of 1’s. The parity bit is set to 1 if there are an odd number of 1s in the preceding $n-1$ bits, and set to 0 otherwise: . bn=∑i=1n−1bi where addition is done modulo 2.b_n = sum_{i=1}^{n-1} b_i quad text{ where addition is done modulo 2.}bn​=i=1∑n−1​bi​ where addition is done modulo 2. . This allows for a single bit error to be detected because if there is a single bit flip, there is no longer an even number of 1’s in the bit string. However, double bit errors cannot be detected. The next step is to add error correcting capability and this is given by the Hamming code (Hamming 1950). The following section will introduce the Hamming(7,4) code which has $n=7$ and $m=4$ (this will have $k=n-m=3$ redundant bits). . Hamming Code . A Hamming code is constructed by assigning the $k$ redundant bits as check bits over select $m$ information bits. If the check bit received in an $n$ bit string matches the computed parity, then a 0 is recorded, and if it disagrees, a 1 is recorded. The sequence of check bits given by $ mathrm{c_k…c_1}$ provides the position of a single error and is called the checking number. If the checking number is zero, then no error was detected. The checking number is required to represent $m+k+1$ combinations giving a condition 2k≥m+k+1  ⟹  2m≤2n/(n+1).2^k geq m+ k + 1 implies 2^m leq 2^n/(n+1).2k≥m+k+1⟹2m≤2n/(n+1). One can check this condition by substituting $n = m+k$. . For the check number to represent the binary number of the error position, the check bits are placed in positions $1,2,4,8,…,2^{k-1}$. The $i^{th}$ check bit records the parity of bit positions which have a 1 in the $i^{th}$ position in the binary representation So the first check bit will have the parity for bit positions: 1,3,5,7,… which have a 1 in the 1st position. The second check bit will have the parity for bit positions: 2,3,6,7,… which have a 1 in the 2nd position. This is summarised in this Table: . Check bit Binary Check bit 2 Binary Check bit 3 Binary . 1 | 1 | 2 | 10 | 4 | 100 | . 3 | 11 | 3 | 11 | 5 | 101 | . 5 | 101 | 6 | 110 | 6 | 110 | . 7 | 111 | 7 | 111 | 7 | 111 | . 9 | 1001 | 10 | 1010 | 12 | 1100 | . 11 | 1011 | 11 | 1011 | 13 | 1101 | . 13 | 1101 | 14 | 1110 | 14 | 1110 | . 15 | 1111 | 15 | 1111 | 15 | 1111 | . Error Detection and Correction Example . Consider a 7 bit string $ mathrm{b_7b_6b_5b_4b_3b_2b_1}= texttt{0111100}$ which encodes a bit string ${ mathrm{m_4 m_3 m_2 m_1} = texttt{b1011} = 11}$ and check bits $ mathrm{k_3 k_2 k_1} = texttt{b001}$. This is the Hamming(7,4) code meaning $n=7$ and $m=4$. . The original bit string: . Suppose the bit $ mathrm{m_2}$ in position 5 has an error so instead of the original 1, it is now 0. The checking number $ mathrm{c_3 c_2 c_1}$ can be computed. In Figure 1, the first parity counts an odd number of 1’s in positions 1,3,5, and 7 so $c_1=1$. . . Next, the second parity counts an even number of 1’s in the positions 2,3,6, and 7 so $c_2=0$. . . The third parity counts an odd number of 1’s in the positions 4,5,6, and 7 so $c_3=1$. . . This gives a checking number $c_3 c_2 c_1= texttt{101}$ which is position 5. Therefore, there is an error in position 5 which can be corrected by converting the 0 into a 1. . Another example of a Hamming code is triple repetition. Each bit is sent three times and majority rules is applied to decode the message. This is Hamming(3,1) and uses 2 parity bits. Using this code, single errors can be corrected or double errors can be detected but not corrected. This makes sense because if a single bit is flipped, the majority rule recovers the correct bit. However, if two bits are flipped, these errors can be detected but if correction is applied, the wrong bit will be reconstructed. The (7,4) code Hamming introduced in his paper can be extended to (8,4) allowing for single error correction and double error detection. . Single Error Correction plus Double Error Detection . Double error detection can be added by using another bit that represents the parity for positions, that when expressed in binary, have a 1 in the $4^{th}$ position. Then there exists three cases with the first being all parity checks pass. The second case is when there is a single error and the last parity check fails. The checking number then gives the position of the error with zero now meaning the error is in the last check position. The last case is then the last parity check is satisfied but the checking number indicates that there is an error. In this case, there is a double error. . Hamming (1950) 3 gives a way of determining what actions can be done (error detection or error correction) by introducing a metric. . Hamming Distance . The distance $D$ between two bit strings ${x}$ and ${y}$ is given by the Hamming distance. . The Hamming distance is given by the number of positions (or coordinates) where two bit strings differ. . This definition satisfies the conditions for a metric: begin{split} D(x,y) = 0 quad &amp; text{iff } x=y D(x,y) = D(y,x) &gt; 0 quad &amp; text{if } x neq y D(x,y) + D(y,z) geq D(x,z) quad &amp; text{triangle inequality.} end{split} . Imagine each code being encoded by corners in a $2^n$ hypercube, then if each code has a distance of $r$ between a neighbouring code, the codes lie on the surface of a $r+1$ sphere centered on some origin. For example, a $r=2$ code with $n=3$ can be: 000, 011, 101, 110. Each code is a distance 2 apart and sit on the corners of a cube as depicted in Figure 5. . . When there is a distance of 2 between the codes, then a single error will convert a point on the cube to a coordinate that is meaningless. This corresponds to single error detection. However, this error cannot be corrected since the false code is equidistant to a number of other true codes. A 3 distance code for $n = 3$ can be: 000, and 111. This is shown in Figure 6. . . When there is a single error, the error can be corrected because the false code will be closer to the correct code than the others. A more detailed list of actions is summarised in the following table. . Minimum Hamming Distance Available Actions . 1 | Unique. No redundancy. | . 2 | Single error detection | . 3 | Single error correction or Double error detection | . 4 | Single error correction + Double error detection or | .   | Triple error detection | . 5 | Double error correction or | .   | Single error correction + Triple error detection or | .   | Quadruple error detection | . From the table above, it can be seen that an extra Hamming distance of 2 is needed to correct an additional error and an extra Hamming distance of 1 is needed to detect an additional error. . Developments in Error Correction Codes . More general codes can be made by constructing a parity check matrix which contains error correction abilities based on linear dependent columns4. From there, the mapping between messages and code can be found using a generator matrix computed from the parity matrix5. The example shown in this blog post relied on operations on a Galois (or finite) field with characteristic 2 (so addition and multiplication is done modulo 2). Other fields can also be used such $ mathbf{F}_{11}$ which is implemented in the User Datagram Protocol (UDP). UDP can also fix erasures - when bits are lost rather than flipped6. There is also a family of Hamming codes which include extensions and shortenings that allow Hamming codes to perform better or improve the redundancy factor7. . Multiple error correction codes can be done using Reed-Solomon (RS)8 and Bose-Chaudhuri-Hocquenghem (BCH)9 which can be hard to decode because the number of errors is not known beforehand. By using primitive polynomials for the Galois field, the coding can be done on Linear Feedback Shift Registers (LFSR)10. The location of errors can be found by solving for the roots of an error locator polynomial11 given by the Massey algorithm12. Roots of the locator polynomial are found using Chien search and the Forney formula gives a way of computing the values for erasures13. Following this, Sugiyama invented a method for decoding Goppa codes based on the Euclidean algorithm and Kerlekamp’s key equation, forgoing the need to find the locator polynomial14. Other decoding methods include the Discrete Fourier Transform (DFT)15. . Many different types of codes exist including cyclic codes and convolutional or continuous codes. For instance, the Chinese remainder theorem is used to decode Fire codes16 which is a type of cyclic code. Convolutional codes can be decoded with the Viterbi algorithm17. Applications of error correcting coding and decoding extend to public key encryption18 amongst others. . Conclusion . The main ideas of error correction codes using the Hamming code were explored with the help of an example. Hamming distance was introduced which gives an indication of what actions can be done depending on the minimum Hamming distance. Finally, a brief overview of developments since Hamming’s paper was given. . References . Brian J Thompson, Robert Rennie Shannon, et al. Space Optics: Proceedings of the Ninth International Congress of the International Commission for Optics (ico IX), volume 9. National Academies, 1974. &#8617; . | Hengyong Yu and Ge Wang. Compressed sensing based interior tomography. Physics in medicine &amp; biology, 54(9):2791, 2009. &#8617; . | Richard W Hamming. Error detecting and error correcting codes. The Bell system technical journal, 29(2):147–160, 1950. &#8617; . | Robert Gallager. Low-density parity-check codes. IRE Transactions on information theory, 8(1):21–28, 1962. &#8617; . | David JC MacKay and Radford M Neal. Near shannon limit performance of low density parity check codes. Electronics letters, 32(18):1645–1646, 1996. &#8617; . | Jon Postel. User datagram protocol. Isi, 1980. &#8617; . | Victor K Wei. Generalized hamming weights for linear codes. IEEE Transactions on information theory, 37(5):1412–1418, 1991. &#8617; . | Stephen B Wicker and Vijay K Bhargava. Reed-Solomon codes and their applications. John Wiley &amp; Sons, 1999. &#8617; . | Robert Chien. Cyclic decoding procedures for bose-chaudhuri-hocquenghem codes. IEEE Transactions on information theory, 10(4):357–363, 1964.9 &#8617; . | Sybille Hellebrand, Janusz Rajski, Steffen Tarnick, Srikanth Venkataraman, and Bernard Courtois. Built-in test for circuits with scan based on reseeding of multiple-polynomial linear feedback shift registers. IEEE Transactions on Computers, 44(2):223–233, 1995. &#8617; . | T-K Truong, J-H Jeng, and Irving S Reed. Fast algorithm for computing the roots of error locator polynomials up to degree 11 in reed-solomon decoders. IEEE Transactions on Communications, 49(5):779–783, 2001. &#8617; . | G-L Feng and Kenneth K Tzeng. A generalization of the berlekamp-massey algorithm for multisequence shift-register synthesis with applications to decoding cyclic codes. IEEE Transactions on Information Theory, 37(5):1274–1287, 1991. &#8617; . | Douglas A Leonard. A generalized forney formula for algebraic-geometric codes. IEEE Transactions on Information Theory, 42(4):1263–1268, 1996. &#8617; . | Yasuo Sugiyama, Masao Kasahara, Shigeichi Hirasawa, and Toshihiko Namekawa. A method for solving key equation for decoding goppa codes. Information and Control, 27(1):87–99, 1975. &#8617; . | Richard E. Blahut. Transform techniques for error control codes. IBM Journal of Research and development, 23(3):299–315, 1979. &#8617; . | R Chien. Burst-correcting codes with high-speed decoding. IEEE Transactions on Information Theory, 15(1):109–113, 1969. &#8617; . | G David Forney. The viterbi algorithm. Proceedings of the IEEE, 61(3):268–278, 1973. &#8617; . | Yuan Xing Li, Robert H Deng, and Xin Mei Wang. On the equivalence of mceliece’s and niederreiter’s public-key cryptosystems. IEEE Transactions on Information Theory, 40(1):271–273, 1994. &#8617; . |",
            "url": "https://yiweimao.github.io/blog/2020/02/15/error_correction.html",
            "relUrl": "/2020/02/15/error_correction.html",
            "date": " • Feb 15, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am doing my PhD at the University of Sydney working on hyperspectral remote sensing. My interests lie in computer vision and machine learning. I am also a musician in my spare time playing the Euphonium in the Parramatta Salvation Army Brass Band. . Experience . ARC Training Centre for CubeSats, UAVs &amp; Their Applications and DST-Group PhD internship (2020 – Current) . | Imagination Technologies Internship (2019 – 2020) . | University of Sydney Casual Academic Tutor (2018 – Current) . | CSIRO Astronomy and Space Science Summer Vacation Research Student (2017 – 2018) . | Sydney Academy of Chess Chess Coach (2015 – 2017) . | University . I studied Mechatronics Engineering and Advanced Science (majored in Physics and Maths) at the University of Sydney. . Academic Papers . Year Paper Title . 2020 | TweetS@: A 3D Printed CubeSat Tweeting From Space | .   | Australian Space Research Conference 2019 Proceedings | . Contact Details . Email: ewaymao@gmail.com Personal blog: https://yiweimao.github.io/blog/ .",
          "url": "https://yiweimao.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://yiweimao.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}